////////////////////////////////////////////////////////////////
// Orkid Media Engine
// Copyright 1996-2020, Michael T. Mayers.
// Distributed under the Boost Software License - Version 1.0 - August 17, 2003
// see http://www.boost.org/LICENSE_1_0.txt
////////////////////////////////////////////////////////////////

#include <ork/lev2/gfx/camera/cameradata.h>
#include <ork/lev2/gfx/gfxenv.h>
#include <ork/lev2/gfx/renderer/renderer.h>
#include <ork/kernel/string/deco.inl>
#include <ork/pch.h>

namespace ork::lev2 {
////////////////////////////////////////////////////////////////////////////////
// CameraData
////////////////////////////////////////////////////////////////////////////////
CameraData::CameraData()
    : mAper(17.0f)
    , mHorizAper(0.0f)
    , mNear(100.0f)
    , mFar(750.0f)
    , mEye(0.0f, 0.0f, 0.0f)
    , mTarget(0.0f, 0.0f, 1.0f)
    , mUp(0.0f, 1.0f, 0.0f)
    , _uiCamera(nullptr) {
}
////////////////////////////////////////////////////////////////////////////////
const fvec3& CameraData::GetEye() const {
  return mEye;
}
////////////////////////////////////////////////////////////////////////////////
const fvec3& CameraData::GetTarget() const {
  return mTarget;
}
////////////////////////////////////////////////////////////////////////////////
const fvec3& CameraData::GetUp() const {
  return mUp;
}
////////////////////////////////////////////////////////////////////////////////
float CameraData::GetNear() const {
  return mNear;
}
////////////////////////////////////////////////////////////////////////////////
float CameraData::GetFar() const {
  return mFar;
}
////////////////////////////////////////////////////////////////////////////////
float CameraData::GetAperature() const {
  return mAper;
}
////////////////////////////////////////////////////////////////////////////////
const fvec3& CameraData::xNormal() const {
  return _xnormal;
}
////////////////////////////////////////////////////////////////////////////////
const fvec3& CameraData::yNormal() const {
  return _ynormal;
}
////////////////////////////////////////////////////////////////////////////////
const fvec3& CameraData::zNormal() const {
  return _znormal;
}
////////////////////////////////////////////////////////////////////////////////
void CameraData::setXNormal(const fvec3& n) {
  _xnormal = n;
}
////////////////////////////////////////////////////////////////////////////////
void CameraData::setYNormal(const fvec3& n) {
  _ynormal = n;
}
////////////////////////////////////////////////////////////////////////////////
void CameraData::setZNormal(const fvec3& n) {
  _znormal = n;
}
////////////////////////////////////////////////////////////////////////////////
lev2::UiCamera* CameraData::getUiCamera() const {
  return _uiCamera;
}
////////////////////////////////////////////////////////////////////////////////
void CameraData::setUiCamera(lev2::UiCamera* pcam) {
  // printf( "CameraMatrices::setUiCamera() this<%p> pcam<%p>\n", this, pcam );
  _uiCamera = pcam;
}
////////////////////////////////////////////////////////////////////////////////
void CameraData::Persp(float fnear, float ffar, float faper) {
  mAper      = faper;
  mHorizAper = 0;
  mNear      = fnear;
  mFar       = ffar;
}
////////////////////////////////////////////////////////////////////////////////
void CameraData::PerspH(float fnear, float ffar, float faperh) {
  mHorizAper = faperh;
  mNear      = fnear;
  mFar       = ffar;
}
////////////////////////////////////////////////////////////////////////////////
void CameraData::Lookat(const fvec3& eye, const fvec3& tgt, const fvec3& up) {
  mEye    = eye;
  mTarget = tgt;
  mUp     = up;
}
////////////////////////////////////////////////////////////////////////////////
CameraMatrices CameraData::computeMatrices(float faspect) const {
  CameraMatrices rval;
  ///////////////////////////////
  // gameplay calculation
  ///////////////////////////////
  float faper = mAper;
  // float faspect = mfAspect;
  float fnear = mNear;
  float ffar  = mFar;
  ///////////////////////////////////////////////////
  if (faper < 1.0f)
    faper = 1.0f;
  if (fnear < 0.1f)
    fnear = 0.1f;
  if (ffar < 0.5f)
    ffar = 0.5f;
  ///////////////////////////////////////////////////
  fvec3 target = mTarget;
  ///////////////////////////////////////////////////
  float fmag2 = (target - mEye).MagSquared();
  if (fmag2 < 0.01f) {
    target = mEye + fvec3::Blue();
  }
  ///////////////////////////////////////////////////
  rval._vmatrix.LookAt(mEye, mTarget, mUp);
  rval._ivmatrix.inverseOf(rval._vmatrix);
  rval._pmatrix.Perspective(faper, faspect, fnear, ffar);
  rval._ipmatrix.inverseOf(rval._pmatrix);
  rval._vpmatrix = rval._vmatrix * rval._pmatrix;
  rval._ivpmatrix.inverseOf(rval._vpmatrix);
  rval._frustum.Set(rval._ivpmatrix);
  ///////////////////////////////////////////////////
  rval._camdat = *this;

  // deco::prints(rval._vmatrix.dump4x3cn(), true);
  return rval;
}
////////////////////////////////////////////////////////////////////////////////
// CameraMatrices
////////////////////////////////////////////////////////////////////////////////
const Frustum& CameraMatrices::GetFrustum() const {
  return _frustum;
}
////////////////////////////////////////////////////////////////////////////////
Frustum& CameraMatrices::GetFrustum() {
  return _frustum;
}
////////////////////////////////////////////////////////////////////////////////
const fmtx4& CameraMatrices::GetIVMatrix() const {
  return _ivmatrix;
}
////////////////////////////////////////////////////////////////////////////////
const fmtx4& CameraMatrices::GetVMatrix() const {
  return _vmatrix;
}
////////////////////////////////////////////////////////////////////////////////
const fmtx4& CameraMatrices::GetPMatrix() const {
  return _pmatrix;
}
////////////////////////////////////////////////////////////////////////////////
const fmtx4& CameraMatrices::GetIVPMatrix() const {
  return _ivpmatrix;
}
////////////////////////////////////////////////////////////////////////////////
const fmtx4& CameraMatrices::GetVPMatrix() const {
  return _vpmatrix;
}
////////////////////////////////////////////////////////////////////
float CameraMatrices::GetAspect() const {
  return _aspectRatio;
}
///////////////////////////////////////////////////////////////////////////////
fmtx4 CameraMatrices::MVPMONO(const fmtx4& M) const {
  // deco::prints(M.dump4x3cn(), true);
  return (M * _vmatrix) * _pmatrix;
}
////////////////////////////////////////////////////////////////////////////////
// StereoCameraMatrices
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::VL() const {
  return _left->GetVMatrix();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::VR() const {
  return _right->GetVMatrix();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::PL() const {
  return _left->GetPMatrix();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::PR() const {
  return _right->GetPMatrix();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::VPL() const {
  return _left->GetVMatrix() * _left->GetPMatrix();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::VPR() const {
  return _right->GetVMatrix() * _right->GetPMatrix();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::VMONO() const {
  return _mono->GetVMatrix();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::PMONO() const {
  return _mono->GetPMatrix();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::VPMONO() const {
  return _mono->GetVMatrix() * _mono->GetPMatrix();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::MVPL(const fmtx4& M) const {
  return (M * VL()) * PL();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::MVPR(const fmtx4& M) const {
  return (M * VR()) * PR();
}
////////////////////////////////////////////////////////////////////////////////
fmtx4 StereoCameraMatrices::MVPMONO(const fmtx4& M) const {
  // deco::prints(M.dump4x3cn(), true);
  return (M * VMONO()) * PMONO();
}
///////////////////////////////////////////////////////////////////////////////
} // namespace ork::lev2
