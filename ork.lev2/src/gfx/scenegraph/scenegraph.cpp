#include <ork/lev2/gfx/scenegraph/scenegraph.h>

namespace ork::lev2::scenegraph {
///////////////////////////////////////////////////////////////////////////////

Node::Node() {

}

///////////////////////////////////////////////////////////////////////////////

Node::~Node() {

}

///////////////////////////////////////////////////////////////////////////////

Layer::Layer(std::string named) 
  : _name(named) {

}

///////////////////////////////////////////////////////////////////////////////

Layer::~Layer(){

}

///////////////////////////////////////////////////////////////////////////////

void Layer::addNode(scenenode_ptr_t node) {

}

///////////////////////////////////////////////////////////////////////////////

void Layer::removeNode(scenenode_ptr_t node) {

}

///////////////////////////////////////////////////////////////////////////////

SceneGraph::SceneGraph(){

}

///////////////////////////////////////////////////////////////////////////////

SceneGraph::~SceneGraph(){

}

///////////////////////////////////////////////////////////////////////////////

scenelayer_ptr_t SceneGraph::createLayer(std::string named){

  auto it = _layers.find(named);
  OrkAssert(it==_layers.end());

  auto l = std::make_shared<Layer>(named);
  _layers[named] = l;
  return l;
}

///////////////////////////////////////////////////////////////////////////////

void SceneGraph::enqueueToRenderer() {
  auto DB = DrawableBuffer::LockWriteBuffer(0);
  DB->Reset();
  //DB->copyCameras(cameras);
  //auto layer = DB->MergeLayer("Default"_pool);
  DrawableBuffer::UnLockWriteBuffer(DB);

}

void SceneGraph::renderOnContext(Context* ctx) {
  auto DB = DrawableBuffer::acquireReadDB(7); 
  if(nullptr == DB) return;
  DrawableBuffer::releaseReadDB(DB);
}

///////////////////////////////////////////////////////////////////////////////
} // ork::lev2::scenegraph