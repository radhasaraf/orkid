///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default { glsl_version = "330"; }
///////////////////////////////////////////////////////////////
// Interfaces
///////////////////////////////////////////////////////////////
uniform_set ublock_vtx {
  mat4 MatMVP;
  mat4 MatMVPL;
  mat4 MatMVPR;
  mat4 MatMV;
  mat4 MatM;
  mat4 MatV;
  mat4 MatP;
  mat4 MatAux;

  vec4 modcolor;
  float Time;
}
///////////////////////////////////////////////////////////////
uniform_set ublock_frg {
  vec4 modcolor;
  sampler2D ColorMap;
  sampler2D ColorMap2;
  sampler2D ColorMap3;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_vdefault : ublock_vtx {
  inputs {
    vec4 position : POSITION;
    vec4 vtxcolor : COLOR0;
    vec2 uv0 : TEXCOORD0;
  }
  outputs {
    vec4 frg_clr;
    vec2 frg_uv0;
  }
}
vertex_interface iface_vdefault_stereo : iface_vdefault {
  outputs {
    layout(secondary_view_offset=1) int gl_Layer;
  }
}
///////////////////////////////////////////////////////////////
fragment_interface iface_fdefault : ublock_frg {
  inputs {
    vec4 frg_clr;
    vec2 frg_uv0;
  }
  outputs { layout(location = 0) vec4 out_clr; }
}
///////////////////////////////////////////////////////////////
fragment_interface iface_fmt : ublock_frg {
  inputs { vec2 frg_uv0; }
  outputs { layout(location = 0) vec4 out_clr; }
}
///////////////////////////////////////////////////////////////
vertex_interface iface_vpick : ublock_vtx {
  inputs {
    vec4 position : POSITION;
    vec4 vtxcolor : COLOR0;
    vec2 uv0 : TEXCOORD0;
  }
  //
  outputs {
    vec4 frg_clr;
    vec2 frg_uv0;
    vec4 frg_nrmd;
  }
}
///////////////////////////////////////////////////////////////
fragment_interface iface_fpick : ublock_frg {
  inputs {
    vec4 frg_clr;
    vec2 frg_uv0;
    vec4 frg_nrmd;
  }
  outputs {
    layout(location = 0) vec4 out_clr;
    layout(location = 1) vec4 out_nrmd;
  }
}
///////////////////////////////////////////////////////////////
// StateBlocks
///////////////////////////////////////////////////////////////
state_block sb_default : default {}
///////////////////////////////////////////////////////////////
state_block sb_lerpblend : sb_default { BlendMode = ALPHA; }
///////////////////////////////////////////////////////////////
state_block sb_additive : sb_default { BlendMode = ADDITIVE; }
///////////////////////////////////////////////////////////////
// shaders
///////////////////////////////////////////////////////////////
fragment_shader ps_texcolor : iface_fmt {
  vec4 texc = texture(ColorMap, frg_uv0);
  out_clr   = vec4(texc.xyz, 1);
}
///////////////////////////////////////////////////////////////
vertex_shader vs_vtxcolor : iface_vdefault {
  gl_Position = MatMVP * position;
  frg_clr     = vtxcolor;
  frg_uv0     = uv0;
}
///////////////////////////////////////////////////////////////
vertex_shader vs_vtxcolor_stereo
  : extension(GL_NV_stereo_view_rendering)
  : extension(GL_NV_viewport_array2)
  : iface_vdefault_stereo {
  gl_Position = MatMVPL * position;
  gl_SecondaryPositionNV = MatMVPR * position;
  gl_Layer = 0;
  gl_ViewportMask[0] = 1;
  gl_SecondaryViewportMaskNV[0] = 2;
  frg_clr     = vtxcolor;
  frg_uv0     = uv0;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_texvtxcolor : iface_fdefault {
  vec4 texc = texture(ColorMap, frg_uv0);
  out_clr   = vec4(texc.xyz * frg_clr.xyz, texc.r);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_distortedfeedback : iface_fdefault {
  // vec2 uvl = texture( ColorMap2, frg_uv0 ).xy;
  vec4 texc = texture(ColorMap, frg_uv0);
  out_clr   = vec4(texc.xyz * frg_clr.xyz, texc.r);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_feedbackatten : iface_fdefault {
  vec4 texc = texture(ColorMap, frg_uv0);
  out_clr   = vec4(0, 0, 0, frg_clr.w);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_fragclr : iface_fdefault {
  out_clr = frg_clr;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_modclr : iface_fmt { out_clr = modcolor; }
///////////////////////////////////////////////////////////////
// pick
///////////////////////////////////////////////////////////////
vertex_shader vs_pick : iface_vpick {
  gl_Position = MatMVP * position;
  vec4 cpos   = MatMV * position;
  vec3 wnorm  = normalize(vec3(0, 1, 0));
  frg_clr     = vtxcolor;
  frg_uv0     = uv0;
  frg_nrmd    = vec4(wnorm, -cpos.z);
}
fragment_shader ps_pick : iface_fpick {
  out_clr  = modcolor;
  out_nrmd = frg_nrmd;
}
///////////////////////////////////////////////////////////////
technique vtxcolor {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_vtxcolor;
    fragment_shader = ps_fragclr;
    state_block     = sb_default;
  }
}
technique vtxmodcolor {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_vtxcolor;
    fragment_shader = ps_fragclr;
    state_block     = sb_default;
  }
}
technique mmodcolor {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_vtxcolor;
    fragment_shader = ps_modclr;
    state_block     = sb_default;
  }
}
technique texcolor {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_vtxcolor;
    fragment_shader = ps_texcolor;
    state_block     = sb_default;
  }
}
technique texcolorstereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_vtxcolor_stereo;
    fragment_shader = ps_texcolor;
    state_block     = sb_default;
  }
}
technique tek_pick {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_pick;
    fragment_shader = ps_pick;
    state_block     = sb_default;
  }
}
technique distortedfeedback {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_vtxcolor;
    fragment_shader = ps_distortedfeedback;
    state_block     = sb_default;
  }
}
technique feedbackatten {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_vtxcolor;
    fragment_shader = ps_feedbackatten;
    state_block     = sb_default;
  }
}
technique texvtxcolor {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_vtxcolor;
    fragment_shader = ps_texvtxcolor;
    state_block     = sb_default;
  }
}
technique texcolorwrap {}
technique texcolorralp {}
technique knob {}
technique texmodcolor {}
technique textexmodcolor {}
technique texmodcolorFB {}
///////////////////////////////////////////////////////////////
