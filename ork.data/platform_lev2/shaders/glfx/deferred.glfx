///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
  glsl_version = "330";
import "misctools.i";
}
///////////////////////////////////////////////////////////////
// Interfaces
///////////////////////////////////////////////////////////////
uniform_block ub_vtx {
  uniform mat4 MatMVP;
  uniform mat4 MatMVPL;
  uniform mat4 MatMVPR;
  uniform mat4 MatMV;
  uniform mat4 MatM;
  uniform mat4 MatV;
  uniform mat4 MatP;
  uniform mat4 MatAux;
  uniform vec4 modcolor;
  uniform float Time;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_vdefault : ub_vtx {
  in vec4 position : POSITION;
  in vec2 uv0 : TEXCOORD0;
  //
  out vec2 frg_uv;
}
///////////////////////////////////////////////////////////////

uniform_block ub_frg {
  uniform sampler2D ColorMap;
  uniform sampler2D ColorMap2;
  uniform sampler2D ColorMap3;
  uniform vec4 User0; // fog color
  uniform vec4 User1; // campos
  uniform vec4 User2; // inverse target size
  uniform float Time;
  uniform mat4 MatAux;
  uniform mat4 MatAux2;
}

fragment_interface iface_fdefault : ub_frg {
  in vec2 frg_uv;
  //
  out vec4 out_clr;
}
///////////////////////////////////////////////////////////////
vertex_shader vs_std : iface_vdefault {
  gl_Position = MatMVP * position;
  frg_uv      = uv0;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_vstereo : iface_vdefault {
  layout(secondary_view_offset=1) out highp int gl_Layer;
}
vertex_shader vs_std_stereo
: iface_vstereo
: extension(GL_NV_stereo_view_rendering)
: extension(GL_NV_viewport_array2)
{
  frg_uv      = uv0;
  ///////////////////////////
  gl_Position = MatMVPL * position;
  gl_SecondaryPositionNV = MatMVPR * position;
  gl_Layer = 0;
  gl_ViewportMask[0] = 1;
  gl_SecondaryViewportMaskNV[0] = 2;
  ///////////////////////////
}
///////////////////////////////////////////////////////////////
fragment_shader ps_baselight : iface_fdefault : lib_pointlight {
  vec3 albedo = texture(ColorMap, frg_uv).xyz;
  vec4 n_mdl  = texture(ColorMap2, frg_uv);
  vec3 n = normalize(n_mdl.xyz);
  float depthtex = texture(ColorMap3, frg_uv).r;
  vec2 scrxy = (gl_FragCoord.xy*User2.xy)*2.0-vec2(1,1);
  vec3 chk = vec3(scrxy.x,scrxy.y,depthtex*2-1.0);
  vec3 wpos = wposxyz(chk).xyz;

  ///////////////////////////
  // test lights (until we hook in the lightmgr lights)
  ///////////////////////////

  //float ddd1 = clamp(1.0 - wpos_d.w * 0.0007, 0, 1);

  ////////////////////
  // start out with "sunlight"
  ////////////////////
  vec3 l = vec3((0.5 + dot(n, vec3(0, 1, 0)) * 0.5)) * 0.25;

  ////////////////////
  // headlight
  ////////////////////

  vec3 l2 = pointlight( wpos.xyz,
                        n,
                        User1.xyz,
                        100,
                        vec3(1.0, 0.8, 0.00));

  //float dd = mod(length(wpos-User1.xyz),100)*0.01;

  ///////////////////////////

  vec3 c = albedo * (l+l2);
  out_clr = vec4(c,1);
}
///////////////////////////////////////////////////////////////
vertex_shader vs_pointlight : iface_vdefault {
  gl_Position = MatMVP * position;
  frg_uv      = vec2(0,0);
}
///////////////////////////////////////////////////////////////
vertex_shader vs_pointlight_stereo
  : iface_vstereo
  : extension(GL_NV_stereo_view_rendering)
  : extension(GL_NV_viewport_array2) {
  frg_uv      = vec2(0,0);
  ///////////////////////////
  gl_Position = MatMVPL * position;
  gl_SecondaryPositionNV = MatMVPR * position;
  gl_Layer = 0;
  gl_ViewportMask[0] = 1;
  gl_SecondaryViewportMaskNV[0] = 2;
  ///////////////////////////
}
///////////////////////////////////////////////////////////////
fragment_shader ps_pointlight : iface_fdefault : lib_pointlight {
  vec3 lightcolor = User0.xyz;
  vec3 lightpos = User1.xyz;
  float lightradius = User1.w;
  vec2 UV = gl_FragCoord.xy*User2.xy;
  vec4 n_mdl  = texture(ColorMap2, UV);
  bool gotspot = length(n_mdl.xyz)>0.0;
  vec3 c = vec3(0,0,0);
  //if( gotspot ){
    float depthtex = texture(ColorMap3, UV).r;
    vec2 scrxy = UV*2.0-vec2(1,1);
    vec3 chk = vec3(scrxy.x,scrxy.y,depthtex*2-1.0);
    vec3 wpos = wposxyz(chk).xyz;
    vec3 albedo = texture(ColorMap, UV).xyz;
    vec3 n = normalize(n_mdl.xyz);
    vec3 l = pointlight(wpos.xyz, n, lightpos, lightradius, lightcolor);
    c =albedo*l;
  //}
  out_clr = vec4(c, 1);
}
///////////////////////////////////////////////////////////////
// StateBlocks
///////////////////////////////////////////////////////////////
state_block sb_default { inherits default; }
///////////////////////////////////////////////////////////////
technique baselight {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_std;
    fragment_shader = ps_baselight;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique baselight_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_std_stereo;
    fragment_shader = ps_baselight;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique pointlight {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_pointlight;
    fragment_shader = ps_pointlight;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique pointlight_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_pointlight_stereo;
    fragment_shader = ps_pointlight;
    state_block     = sb_default;
  }
}
