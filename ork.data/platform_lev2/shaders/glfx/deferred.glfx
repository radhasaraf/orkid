///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
  glsl_version = "330";
  import "mathtools.i";
  import "misctools.i";
  import "envtools.i";
  import "brdftools.i";
}
///////////////////////////////////////////////////////////////
// Interfaces
///////////////////////////////////////////////////////////////
uniform_set ub_vtx {
  mat4 MVPC;
  mat4 MVPL;
  mat4 MVPR;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_v2uv : ub_vtx {
  inputs {
    vec4 position : POSITION;
    vec2 uv0 : TEXCOORD0;
    vec2 uv1 : TEXCOORD1;
  }
  outputs {
    vec2 frg_uva;
    vec2 frg_uvb;
  }
}
///////////////////////////////////////////////////////////////
uniform_set ub_frg {
  mat4 IVPArray[2];
  mat4 VArray[2];
  mat4 PArray[2];
  sampler2D MapAlbedoAo;
  sampler2D MapNormalL;
  sampler2D MapDepthCluster;
  sampler2D MapRufMtlAlpha;
  sampler2D MapDepth;
  sampler2D MapSpecularEnv;
  sampler2D MapDiffuseEnv;
  sampler2D MapBrdfIntegration;
  sampler2D MapLightingCookie;
  vec2 InvViewportSize; // inverse target size
  float Time;
  vec2 NearFar;
  int NumLights;
  int TileDim;
  vec2 Zndc2eye;
  float SkyboxLevel;
  float SpecularLevel;
  float DiffuseLevel;
  vec3 AmbientLevel;
  float EnvironmentMipBias;
  float EnvironmentMipScale;
  float DepthFogDistance;
  float DepthFogPower;
}
///////////////////////////////////////////////////////////////
uniform_block ub_light {
  vec4 LightColorD[256];
  mat4 LightMatrix[256];
  float LightRadius[256];
}
///////////////////////////////////////////////////////////////
fragment_interface iface_f2uv {
  inputs {
    vec2 frg_uva;
    vec2 frg_uvb;
  }
  outputs { vec4 out_clr; }
}
///////////////////////////////////////////////////////////////
libblock lib_deferred : ub_light : ub_frg : lib_math : lib_envmapping : lib_cellnoise : lib_brdf {
  /////////////////////////////////////////////////////////
  struct GBufData {
    vec2 _uv;
    vec3 _wpos;
    vec3 _wnrm;
    vec3 _albedo;
    float _zeye;
    float _fogZ;
  };
  struct WPosData {
    vec2 _muv;
    vec2 _scruv;
    mat4 _ivp;
    int _index;
  };
  /////////////////////////////////////////////////////////
  float eyedepth(vec2 depthuv) {
    float depthtex = texture(MapDepth, depthuv).r;
    float ndc      = depthtex * 2.0 - 1.0;
    return Zndc2eye.x / (ndc - Zndc2eye.y);
  }
  /////////////////////////////////////////////////////////
  vec3 posatdepth(WPosData wpd, float depth){
    vec2 scrxy     = wpd._scruv * 2.0 - vec2(1, 1);
    vec3 inpos     = vec3(scrxy.x, scrxy.y, depth * 2 - 1.0);
    vec4 rr        = wpd._ivp * vec4(inpos, 1);
    vec3 pos    = vec3(rr.xyz / rr.w);
    return pos;
  }
  /////////////////////////////////////////////////////////
  struct wposout {
    vec4 _out;
    float _fogZ;
  };
  /////////////////////////////////////////////////////////
  wposout defwpos(WPosData wpd) {
    float depthtex = texture(MapDepth, wpd._muv).r;
    vec2 scrxy     = wpd._scruv * 2.0 - vec2(1, 1);
    vec3 inpos     = vec3(scrxy.x, scrxy.y, depthtex * 2 - 1.0);
    vec4 rr        = wpd._ivp * vec4(inpos, 1);
    float ndc      = depthtex * 2.0 - 1.0;
    float zeye     = Zndc2eye.x / (ndc - Zndc2eye.y);
    vec3 wpos      = vec3(rr.xyz / rr.w);

    wposout o;
    o._out = vec4(wpos, zeye);
            // Zndc2eye.x / (ndc-Zndc2eye.y)
    o._fogZ = -0.5 / (ndc - 1.00005); // temp hack until we get VR linear depth working
    return o;
  }
  /////////////////////////////////////////////////////////
  GBufData decodeGBUF(WPosData wpd) {
    wposout o = defwpos(wpd);
    vec4 wpres = o._out;
    GBufData decoded;

    decoded._uv     = wpd._muv;
    decoded._wpos   = wpres.xyz;
    decoded._zeye   = wpres.w;
    vec4 n_mdl      = texture(MapNormalL, decoded._uv);
    decoded._wnrm   = normalize(n_mdl.xyz*2.0-vec3(1));
    decoded._albedo = texture(MapAlbedoAo, decoded._uv).xyz;
    decoded._fogZ = o._fogZ;

    return decoded;
  }
  /////////////////////////////////////////////////////////
  vec3 gammaCorrect(vec3 inp){
    return inp;
    //return pow(inp, vec3(1.0/1.6));
  }
  /////////////////////////////////////////////////////////
  vec3 baselighting(WPosData wpd) {
    GBufData gbd = decodeGBUF(wpd);
    // sunlight ///////////////
    vec3 l = vec3((0.5 + dot(gbd._wnrm, vec3(0, 1, 0)) * 0.5)) * 0.25;
    ///////////////////////////
    return gbd._albedo * l;
  }
  /////////////////////////////////////////////////////////
  struct PointLightCtx {
    vec3 _viewdir;
    vec3 _normal;
    vec3 _lightdel;
    vec3 _F0;
    float _roughness;
    float _metallic;
  };
  /////////////////////////////////////////////////////////
  PointLightCtx plcalc1(WPosData wpd,GBufData gbd,vec4 rmao){
    PointLightCtx plc;
    const vec3 metalbase = vec3(0.04);
    float metallic = clamp(rmao.x,0.02,0.99);
    vec3 basecolor = gbd._albedo;
    vec3 diffcolor = mix(basecolor,vec3(0),metallic);
    vec3 speccolor = mix(vec3(0.02),basecolor,metallic);
    /////////////////////////
    vec3 wpos = gbd._wpos;
    vec3 epos = posatdepth(wpd,0.0);
    /////////////////////////
    plc._viewdir = normalize(epos-wpos);
    plc._metallic = metallic;
    plc._roughness = rmao.y;
    plc._normal = normalize(texture(MapNormalL, wpd._muv).xyz*2-vec3(1));
    plc._F0 = mix(metalbase,basecolor,metallic);
    return plc;
  }
  /////////////////////////////////////////////////////////
  vec3 plcalc2(PointLightCtx plc,GBufData gbd){
      float dist2lightsq = plc._lightdel.x*plc._lightdel.x
                         + plc._lightdel.y*plc._lightdel.y
                         + plc._lightdel.z*plc._lightdel.z;
      float atten = 1.0 / dist2lightsq;
      vec3 lightdir = normalize(plc._lightdel);
      vec3 halfdir = normalize(plc._viewdir + lightdir);
      float ggx = computeGGX(plc._normal, halfdir, plc._roughness);
      float geo = geometrySmith(plc._normal, plc._viewdir, lightdir, plc._roughness);
      vec3 fres = fresnelSchlickRoughness(satdot(halfdir,plc._viewdir), plc._F0,plc._roughness);
      vec3 numerator  = ggx * geo * fres * SpecularLevel;
      float denominator = 4 * satdot(plc._normal,plc._viewdir) * satdot(plc._normal, lightdir) + EPSILON;
      vec3 diffusel = vec3(1) - fres;
      diffusel *= (1 - plc._metallic);
      float ndotl = satdot(plc._normal,lightdir);
      vec3 diffuse_term = (diffusel*gbd._albedo*INV_PI)*DiffuseLevel;
      vec3 specular_term = numerator / denominator;
      return (diffuse_term + specular_term) * atten * ndotl;
  }
  /////////////////////////////////////////////////////////
  vec3 pntlighting_clustered(WPosData wpd,GBufData gbd) {
    vec4 rmao = texture(MapRufMtlAlpha,wpd._muv); // ruf mtl ao opa
    int lbas     = int(frg_uvb.x);
    int numl     = int(frg_uvb.y);
    vec3 l       = vec3(0, 0, 0);
    if( rmao.w==0 ){
      PointLightCtx plc = plcalc1(wpd,gbd,rmao);
      for (int i = 0; i < numl; i++) {
        int lidx                     = lbas + i;
        float lightcamdepth          = LightColorD[lidx].w;
        bool sphere_intersects_depth = (gbd._zeye - lightcamdepth) < LightRadius[lidx];
        if (sphere_intersects_depth){
          vec3 lightpos = (LightMatrix[lidx]*vec4(0,0,0,1)).xyz;
          vec3 lightdel = lightpos - gbd._wpos;
          plc._lightdel = lightdel;
          vec3 lightn = normalize(lightdel)*mat3(LightMatrix[lidx]);
          vec3 lighttex = env_equirectangularFlipV(lightn,MapLightingCookie,0);
          vec3 lightcol = LightColorD[lidx].xyz;
          l += plcalc2(plc,gbd)*lighttex*lightcol;
        }
      }
    }
    return gammaCorrect(l);
  }
  /////////////////////////////////////////////////////////
  vec3 pntlighting_textured_simple(WPosData wpd,GBufData gbd) {
    vec4 rmao = texture(MapRufMtlAlpha,wpd._muv); // ruf mtl ao opa
    vec3 l       = vec3(0, 0, 0);
    if( rmao.w==0 ){
      PointLightCtx plc = plcalc1(wpd,gbd,rmao);
      int lbeg = int(frg_uvb.x);
      int lend = lbeg+int(frg_uvb.y);
      for (int lidx = lbeg; lidx<lend; lidx++) {
        vec3 lightpos = LightMatrix[lidx][3].xyz;
        plc._lightdel = lightpos - gbd._wpos;
        vec3 lightn = normalize(plc._lightdel)*mat3(LightMatrix[lidx]);
        vec3 lighttex = env_equirectangularFlipV(lightn,MapLightingCookie,0);
        vec3 lightcol = LightColorD[lidx].xyz;
        l += plcalc2(plc,gbd)*lighttex*lightcol;
      }
    }
    float depth_fogval = 1.0-clamp(pow(gbd._fogZ*DepthFogDistance,DepthFogPower),0,1);
    return gammaCorrect(l*depth_fogval);
  }
  /////////////////////////////////////////////////////////
  vec3 pntlighting_untextured_simple(WPosData wpd,GBufData gbd) {
    vec4 rmao = texture(MapRufMtlAlpha,wpd._muv); // ruf mtl ao opa
    vec3 l       = vec3(0, 0, 0);
    if( rmao.w==0 ){
      PointLightCtx plc = plcalc1(wpd,gbd,rmao);
      int lbeg = int(frg_uvb.x);
      int lend = lbeg+int(frg_uvb.y);
      for (int lidx = lbeg; lidx<lend; lidx++) {
        vec3 lightpos = LightMatrix[lidx][3].xyz;
        plc._lightdel = lightpos - gbd._wpos;
        vec3 lightcol = LightColorD[lidx].xyz;
        l += plcalc2(plc,gbd)*lightcol;
      }
    }
    float depth_fogval = 1.0-clamp(pow(gbd._fogZ*DepthFogDistance,DepthFogPower),0,1);
    return gammaCorrect(l*depth_fogval);
  }
  /////////////////////////////////////////////////////////
  vec3 spotlighting_textured_simple(WPosData wpd,GBufData gbd) {
    vec4 rmao = texture(MapRufMtlAlpha,wpd._muv); // ruf mtl ao opa
    vec3 l       = vec3(0, 0, 0);
    if( rmao.w==0 ){
      PointLightCtx plc = plcalc1(wpd,gbd,rmao);
      int lbeg = int(frg_uvb.x);
      int lend = lbeg+int(frg_uvb.y);
      for (int lidx = lbeg; lidx<lend; lidx++) {
        vec3 lightpos = -LightMatrix[lidx][3].xyz;
        plc._lightdel = lightpos - gbd._wpos;
        //vec3 lightn = normalize(plc._lightdel)*mat3(LightMatrix[lidx]);
        float lightrange = LightRadius[lidx];
        vec4 light_hpos = LightMatrix[lidx]*vec4(gbd._wpos,1);
        vec3 light_ndc = (light_hpos.xyz / light_hpos.w);
        vec2 light_uv = light_ndc.xy*0.5+vec2(0.5);
        float mask = float(light_ndc.x>=-1 && light_ndc.x<1) *
                     float(light_ndc.y>=-1 && light_ndc.y<1) *
                     float(light_hpos.z>=0.0 && light_hpos.z<=lightrange) ;
        vec3 lightcol = LightColorD[lidx].xyz;
        vec3 lighttex = texture(MapLightingCookie,light_uv).xyz;
        vec3 lightoutput = lightcol*lighttex*mask;

        l += plcalc2(plc,gbd)*lightoutput;
      }
    }
    float depth_fogval = 1.0-clamp(pow(gbd._fogZ*DepthFogDistance,DepthFogPower),0,1);
    return gammaCorrect(l*depth_fogval);
  }
  /////////////////////////////////////////////////////////
  vec3 spotlighting_untextured_simple(WPosData wpd,GBufData gbd) {
    vec4 rmao = texture(MapRufMtlAlpha,wpd._muv); // ruf mtl ao opa
    vec3 l       = vec3(0, 0, 0);
    if( rmao.w==0 ){
      PointLightCtx plc = plcalc1(wpd,gbd,rmao);
      int lbeg = int(frg_uvb.x);
      int lend = lbeg+int(frg_uvb.y);
      for (int lidx = lbeg; lidx<lend; lidx++) {
        vec3 lightpos = LightMatrix[lidx][3].xyz;
        plc._lightdel = lightpos - gbd._wpos;
        vec3 lightcol = LightColorD[lidx].xyz;
        l += plcalc2(plc,gbd)*lightcol;
      }
    }
    float depth_fogval = 1.0-clamp(pow(gbd._fogZ*DepthFogDistance,DepthFogPower),0,1);
    return gammaCorrect(l*depth_fogval);
  }
  /////////////////////////////////////////////////////////
  vec3 pbrEnvironmentLighting(WPosData wpd){

    vec3 rval;

    GBufData gbd = decodeGBUF(wpd);

    vec2 uv   = wpd._muv;
    vec4 rmao = texture(MapRufMtlAlpha,uv); // ruf mtl ao opa

    vec3 metalbase = vec3(0.04);

    vec3 view_epos0 = posatdepth(wpd,0.0);
    vec3 view_epos1 = posatdepth(wpd,1.0);
    vec3 VIEW_N = normalize(view_epos1-view_epos0);
    vec3 skybox_n = vec3(VIEW_N.x,-VIEW_N.y,VIEW_N.z);
    vec3 skyboxColor = env_equirectangularFlipV(skybox_n,MapSpecularEnv,EnvironmentMipBias)*SkyboxLevel;

    float depth_fogval = clamp(pow(gbd._fogZ*DepthFogDistance,DepthFogPower),0,1);

    if( rmao.w==0 ){
      /////////////////////////
      // pixel was written to in the gbuffer
      float metallic = clamp(rmao.x,0.02,0.99);
      float roughness = rmao.y;
      float roughnessE = roughness*roughness;
      float roughnessL = max(.01,roughness);
      float dialetric = 1.0-metallic;
      /////////////////////////
      vec3 basecolor = gbd._albedo;
      vec3 diffcolor = mix(basecolor,vec3(0),metallic);
      /////////////////////////
      vec3 wpos = gbd._wpos;
      vec3 epos = posatdepth(wpd,0.0);
      vec3 edir = normalize(wpos-epos);
      vec3 rawn = texture(MapNormalL, uv).xyz;
      vec3 n    = normalize(rawn*2-vec3(1));
      vec3 refl = normalize(reflect(edir,n));
      /////////////////////////
      float costheta = clamp(dot(n, edir),0.01,1.0);
      vec2 brdf  = textureGather(MapBrdfIntegration, vec2(costheta,pow(roughness,0.25)),0).rg;
      ///////////////////////////
      // somethings wrong with the brdf output here
      //   we get speckled black noise
      //   the following 2 lines and the clamp above on
      //   costheta are a temporary fix
      ///////////////////////////
      //brdf = vec2(pow(brdf.x,1),pow(brdf.y,1));
      brdf = clamp(brdf,vec2(.001),vec2(1));
      /////////////////////////
      vec3 F0 = mix(metalbase,basecolor,metallic);
      vec3 F        = fresnelSchlickRoughness(costheta, F0, roughness);
      vec3 invF     = (vec3(1)-F);
      vec3 diffn = vec3(n.x,-n.y,n.z);
      /////////////////////////
      float ambocc = rmao.z;
      float ambientshade = ambocc*clamp(dot(n,-edir),0,1)*0.3+0.7;
      vec3 ambient = AmbientLevel*ambientshade;
      vec3 diffuse_env = env_equirectangular(diffn,MapDiffuseEnv,0)*DiffuseLevel;
      vec3 diffuse_light = ambient+diffuse_env;
      /////////////////////////
      vec3 diffuse = basecolor*diffuse_light*dialetric*ambocc;//*invF;
      if( rawn==vec3(0,0,0) )
        diffuse = basecolor;
      /////////////////////////
      float spec_miplevel = clamp(EnvironmentMipBias + (roughness * EnvironmentMipScale), 0, 10);
      refl = vec3(refl.x,-refl.y,refl.z);
      vec3 spec_env = env_equirectangularFlipV(refl,MapSpecularEnv,spec_miplevel);
      vec3 specular_light = ambient+spec_env;
      vec3 specular = (F*brdf.x+brdf.y)*specular_light*F0*SpecularLevel;
      //vec3 ambient = invF*AmbientLevel;
      /////////////////////////
      /////////////////////////
      // final linear color
      /////////////////////////
      vec3 finallitcolor = diffuse+specular;
      //rval = vec3(n);
      /////////////////////////
      // HDR tonemapping
      /////////////////////////
      //rval = rval / (rval + vec3(1.0));
      /////////////////////////
      // gamma correct
      /////////////////////////
      rval = mix(finallitcolor,skyboxColor,depth_fogval);
      //rval = basecolor;
    }
    else{
      // pixel was blank to in the gbuffer
      //  replace with environment
      rval = skyboxColor;
    }
    return gammaCorrect(rval);
  } // vec3 environmentLighting(){

WPosData stereoWPD(){
    WPosData wpd;
    wpd._muv   = gl_FragCoord.xy * InvViewportSize;
    int index = int(wpd._muv.x >= 0.5);
    wpd._ivp   = IVPArray[index];
    wpd._scruv = wpd._muv;
    wpd._scruv.x = mod(wpd._scruv.x * 2, 1);
    wpd._index = index;
    return wpd;
}
WPosData monoWPD(){
  WPosData wpd;
  wpd._muv   = gl_FragCoord.xy * InvViewportSize;
  wpd._index = 0;
  wpd._ivp   = IVPArray[0];
  wpd._scruv = wpd._muv;
  return wpd;
}
///////////////////////////////////////////////////////////////
} // libblock lib_deferred : ub_light : ub_frg {
///////////////////////////////////////////////////////////////
vertex_shader vs_passthru2uv : iface_v2uv {
  frg_uva     = uv0;
  frg_uvb     = uv1;
  gl_Position = position;
}
///////////////////////////////////////////////////////////////
fragment_interface iface_fdownsampledepthcluster {
  inputs {
    vec2 frg_uva;
    vec2 frg_uvb;
  }
  outputs { uint out_depthclusters; }
}
fragment_shader ps_downsampledepthcluster : iface_fdownsampledepthcluster : lib_deferred {
  vec2 base       = (gl_FragCoord.xy - vec2(0.5, 0.5)) * float(TileDim);
  uint clusterset = 0;
  for (int iy = 0; iy < TileDim; iy++) {
    for (int ix = 0; ix < TileDim; ix++) {
      vec2 uv              = base + vec2(ix, iy);
      uv                   = uv * InvViewportSize;
      float depthtex       = texture(MapDepth, uv).x;
      float ndc            = depthtex * 2.0 - 1.0;
      float zeye           = Zndc2eye.x / (ndc - Zndc2eye.y);
      uint clusterbitindex = uint(log2(zeye));
      clusterset           = clusterset | (1u << clusterbitindex);
    }
  }
  out_depthclusters = clusterset;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_baselight : iface_f2uv : lib_deferred {
  WPosData wpd = monoWPD();
  vec3 c     = baselighting(wpd);
  out_clr    = vec4(c, 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_baselight_stereo : iface_f2uv : lib_deferred {
  WPosData wpd = stereoWPD();
  vec3 c       = baselighting(wpd);
  out_clr      = vec4(c, 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_pointlight_textured : iface_f2uv : lib_deferred {
  WPosData wpd = monoWPD();
  GBufData gbd = decodeGBUF(wpd);
  out_clr = vec4(pntlighting_textured_simple(wpd,gbd), 1);
  /////////////////////////////////////////
  // show lighting tiles
  /////////////////////////////////////////
  //float dp5  = distance(frg_uva, vec2(.5, .5));
  //c += vec3(pow(dp5, 17) * 256.0);
  /////////////////////////////////////////
}
///////////////////////////////////////////////////////////////
fragment_shader ps_pointlight_untextured : iface_f2uv : lib_deferred {
  WPosData wpd = monoWPD();
  GBufData gbd = decodeGBUF(wpd);
  out_clr = vec4(pntlighting_untextured_simple(wpd,gbd), 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_pointlight_textured_stereo : iface_f2uv : lib_deferred {
  WPosData wpd = stereoWPD();
  GBufData gbd = decodeGBUF(wpd);
  out_clr = vec4(pntlighting_textured_simple(wpd,gbd), 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_pointlight_untextured_stereo : iface_f2uv : lib_deferred {
  WPosData wpd = stereoWPD();
  GBufData gbd = decodeGBUF(wpd);
  out_clr = vec4(pntlighting_untextured_simple(wpd,gbd), 1);
}
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
fragment_shader ps_spotlight_textured : iface_f2uv : lib_deferred {
  WPosData wpd = monoWPD();
  GBufData gbd = decodeGBUF(wpd);
  out_clr = vec4(spotlighting_textured_simple(wpd,gbd), 1);
  /////////////////////////////////////////
  // show lighting tiles
  /////////////////////////////////////////
  //float dp5  = distance(frg_uva, vec2(.5, .5));
  //c += vec3(pow(dp5, 17) * 256.0);
  /////////////////////////////////////////
}
///////////////////////////////////////////////////////////////
fragment_shader ps_spotlight_untextured : iface_f2uv : lib_deferred {
  WPosData wpd = monoWPD();
  GBufData gbd = decodeGBUF(wpd);
  out_clr = vec4(spotlighting_untextured_simple(wpd,gbd), 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_spotlight_textured_stereo : iface_f2uv : lib_deferred {
  WPosData wpd = stereoWPD();
  GBufData gbd = decodeGBUF(wpd);
  out_clr = vec4(spotlighting_textured_simple(wpd,gbd), 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_spotlight_untextured_stereo : iface_f2uv : lib_deferred {
  WPosData wpd = stereoWPD();
  GBufData gbd = decodeGBUF(wpd);
  out_clr = vec4(spotlighting_untextured_simple(wpd,gbd), 1);
}
///////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////
fragment_shader ps_environment : iface_f2uv : lib_deferred  {
  WPosData wpd = monoWPD();
  out_clr = vec4(pbrEnvironmentLighting(wpd),1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_environment_stereo : iface_f2uv : lib_deferred  {
  WPosData wpd = stereoWPD();
  vec3 c = pbrEnvironmentLighting(wpd);
  out_clr = vec4(c,1);
}
///////////////////////////////////////////////////////////////
// StateBlocks
///////////////////////////////////////////////////////////////
state_block sb_default : default {}
///////////////////////////////////////////////////////////////
technique baselight {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_baselight;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique baselight_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_baselight_stereo;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique pointlight_textured {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_pointlight_textured;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique pointlight_untextured {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_pointlight_untextured;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique pointlight_textured_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_pointlight_textured_stereo;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique pointlight_untextured_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_pointlight_untextured_stereo;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique spotlight_textured {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_spotlight_textured;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique spotlight_untextured {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_spotlight_untextured;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique spotlight_textured_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_spotlight_textured_stereo;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique spotlight_untextured_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_spotlight_untextured_stereo;
    state_block     = sb_default;
  }
}///////////////////////////////////////////////////////////////
technique downsampledepthcluster {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_downsampledepthcluster;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique environmentlighting {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_environment;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique environmentlighting_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_environment_stereo;
    state_block     = sb_default;
  }
}
