///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
  glsl_version = "330";
  import "mathtools.i";
  import "misctools.i";
  import "envtools.i";
  import "brdftools.i";
}
///////////////////////////////////////////////////////////////
// Interfaces
///////////////////////////////////////////////////////////////
uniform_set ub_vtx {
  mat4 MVPC;
  mat4 MVPL;
  mat4 MVPR;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_v2uv : ub_vtx {
  inputs {
    vec4 position : POSITION;
    vec2 uv0 : TEXCOORD0;
    vec2 uv1 : TEXCOORD1;
  }
  outputs {
    vec2 frg_uva;
    vec2 frg_uvb;
  }
}
///////////////////////////////////////////////////////////////
uniform_set ub_frg {
  mat4 IVPArray[2];
  mat4 VArray[2];
  mat4 PArray[2];
  sampler2D MapAlbedoAo;
  sampler2D MapNormalL;
  sampler2D MapDepthCluster;
  sampler2D MapRufMtlAlpha;
  sampler2D MapDepth;
  sampler2D MapSpecularEnv;
  sampler2D MapDiffuseEnv;
  sampler2D MapBrdfIntegration;
  sampler2D MapLightingCookie;
  vec2 InvViewportSize; // inverse target size
  float Time;
  vec2 NearFar;
  int NumLights;
  int TileDim;
  vec2 Zndc2eye;
  float SkyboxLevel;
  float SpecularLevel;
  float DiffuseLevel;
  vec3 AmbientLevel;
  float EnvironmentMipBias;
  float EnvironmentMipScale;
  float DepthFogDistance;
  float DepthFogPower;
}
///////////////////////////////////////////////////////////////
uniform_block ub_light {
  vec4 LightColorD[256];
  mat4 LightMatrix[256];
  float LightRadius[256];
}
///////////////////////////////////////////////////////////////
fragment_interface iface_f2uv {
  inputs {
    vec2 frg_uva;
    vec2 frg_uvb;
  }
  outputs { vec4 out_clr; }
}
///////////////////////////////////////////////////////////////
libblock lib_deferred : ub_light : ub_frg : lib_math : lib_envmapping : lib_cellnoise : lib_brdf {
  /////////////////////////////////////////////////////////
  struct GBufData {
    vec2 _uv;
    vec3 _wpos;
    vec3 _wnrm;
    vec3 _albedo;
    float _zeye;
    float _fogZ;
  };
  struct WPosData {
    vec2 _muv;
    vec2 _scruv;
    mat4 _ivp;
    int _index;
  };
  /////////////////////////////////////////////////////////
  float eyedepth(vec2 depthuv) {
    float depthtex = texture(MapDepth, depthuv).r;
    float ndc      = depthtex * 2.0 - 1.0;
    return Zndc2eye.x / (ndc - Zndc2eye.y);
  }
  /////////////////////////////////////////////////////////
  vec3 posatdepth(WPosData wpd, float depth){
    vec2 scrxy     = wpd._scruv * 2.0 - vec2(1, 1);
    vec3 inpos     = vec3(scrxy.x, scrxy.y, depth * 2 - 1.0);
    vec4 rr        = wpd._ivp * vec4(inpos, 1);
    vec3 pos    = vec3(rr.xyz / rr.w);
    return pos;
  }
  /////////////////////////////////////////////////////////
  struct wposout {
    vec4 _out;
    float _fogZ;
  };
  /////////////////////////////////////////////////////////
  wposout defwpos(WPosData wpd) {
    float depthtex = texture(MapDepth, wpd._muv).r;
    vec2 scrxy     = wpd._scruv * 2.0 - vec2(1, 1);
    vec3 inpos     = vec3(scrxy.x, scrxy.y, depthtex * 2 - 1.0);
    vec4 rr        = wpd._ivp * vec4(inpos, 1);
    float ndc      = depthtex * 2.0 - 1.0;
    float zeye     = Zndc2eye.x / (ndc - Zndc2eye.y);
    vec3 wpos      = vec3(rr.xyz / rr.w);
    wposout o;
    o._out = vec4(wpos, zeye);
            // Zndc2eye.x / (ndc-Zndc2eye.y)
    o._fogZ = -0.5 / (ndc - 1.00005); // temp hack until we get VR linear depth working
    return o;
  }
  /////////////////////////////////////////////////////////
  GBufData decodeGBUF(WPosData wpd) {
    wposout o = defwpos(wpd);
    vec4 wpres = o._out;
    GBufData decoded;

    decoded._uv     = wpd._muv;
    decoded._wpos   = wpres.xyz;
    decoded._zeye   = wpres.w;
    vec4 n_mdl      = texture(MapNormalL, decoded._uv);
    decoded._wnrm   = normalize(n_mdl.xyz);
    decoded._albedo = texture(MapAlbedoAo, decoded._uv).xyz;
    decoded._fogZ = o._fogZ;

    return decoded;
  }
  /////////////////////////////////////////////////////////
  vec3 baselighting(WPosData wpd) {
    GBufData gbd = decodeGBUF(wpd);
    // sunlight ///////////////
    vec3 l = vec3((0.5 + dot(gbd._wnrm, vec3(0, 1, 0)) * 0.5)) * 0.25;
    ///////////////////////////
    return gbd._albedo * l;
  }
  /////////////////////////////////////////////////////////
  vec3 pntlighting(WPosData wpd,GBufData gbd) {
    vec2 uv   = wpd._muv;
    vec4 rmao = texture(MapRufMtlAlpha,uv); // ruf mtl ao opa

    vec3 l       = vec3(0, 0, 0);
    int lbas     = int(frg_uvb.x);
    int numl     = int(frg_uvb.y);
    vec3 metalbase = vec3(0.04);
    if( rmao.w==0 ){
      /////////////////////////
      // pixel was written to in the gbuffer
      float metallic = clamp(rmao.x,0.02,0.99);
      float roughness = rmao.y;
      float roughnessE = roughness*roughness;
      float roughnessL = max(.01,roughness);
      float dialetric = 1.0-metallic;
      /////////////////////////
      vec3 basecolor = gbd._albedo;
      vec3 diffcolor = mix(basecolor,vec3(0),metallic);
      vec3 speccolor = mix(vec3(0.02),basecolor,metallic);
      vec3 F0 = mix(metalbase,basecolor,metallic);
      /////////////////////////
      vec3 wpos = gbd._wpos;
      vec3 epos = posatdepth(wpd,0.0);
      vec3 edir = normalize(wpos-epos);
      vec3 n    = normalize(texture(MapNormalL, uv).xyz*2-vec3(1));
      vec3 refl = normalize(reflect(edir,n));
      /////////////////////////
      float costheta = clamp(dot(n, edir),0.01,1.0);
      vec2 brdf  = textureGather(MapBrdfIntegration, vec2(costheta,pow(roughness,0.25)),0).rg;
      vec3 v = -edir;
      /////////////////////////
      for (int i = 0; i < numl; i++) {
        int lidx                     = lbas + i;
        float lightcamdepth          = LightColorD[lidx].w;
        bool sphere_intersects_depth = (gbd._zeye - lightcamdepth) < LightRadius[lidx];
        if (sphere_intersects_depth){
          vec3 lightpos = (LightMatrix[lidx]*vec4(0,0,0,1)).xyz;
          vec3 lightdel = lightpos - wpos;
          vec3 lightn = normalize(lightdel)*mat3(LightMatrix[lidx]);

          vec3 lighttex = env_equirectangularFlipV(lightn,MapLightingCookie,0);

          float dist2lightsq = lightdel.x*lightdel.x
                             + lightdel.y*lightdel.y
                             + lightdel.z*lightdel.z;
          float atten = 1.0 / dist2lightsq;
          vec3 lightdir = normalize(lightdel);
          vec3 halfdir = normalize(v + lightdir);
          vec3 radiance = LightColorD[lidx].xyz * atten*lighttex;
          float ggx = computeGGX(n, halfdir, roughness);
          float geo = geometrySmith(n, v, lightdir, roughness);
          vec3 fres = fresnelSchlickRoughness(satdot(halfdir,v), F0,roughness);
          vec3 numerator  = ggx * geo * fres * SpecularLevel;
          float denominator = 4.0 * satdot(n,v) * satdot(n, lightdir) + EPSILON;
          vec3 specular = numerator / denominator;
          vec3 diffusel = vec3(1.0) - fres;
          diffusel *= (1.0 - metallic);
          float ndotl = satdot(n,lightdir);
          vec3 diffuse_term = (diffusel*gbd._albedo*INV_PI)*DiffuseLevel;
          l += (diffuse_term + specular) * radiance * ndotl;
        }
      }
    }
    return l;
  }
  /////////////////////////////////////////////////////////
  vec3 pbrEnvironmentLighting(WPosData wpd){

    vec3 rval;

    GBufData gbd = decodeGBUF(wpd);

    vec2 uv   = wpd._muv;
    vec4 rmao = texture(MapRufMtlAlpha,uv); // ruf mtl ao opa

    vec3 metalbase = vec3(0.04);

    vec3 view_epos0 = posatdepth(wpd,0.0);
    vec3 view_epos1 = posatdepth(wpd,1.0);
    vec3 VIEW_N = normalize(view_epos1-view_epos0);
    vec3 skybox_n = vec3(VIEW_N.x,-VIEW_N.y,VIEW_N.z);
    vec3 skyboxColor = env_equirectangularFlipV(skybox_n,MapSpecularEnv,EnvironmentMipBias)*SkyboxLevel;

    float depth_fogval = clamp(pow(gbd._fogZ*DepthFogDistance,DepthFogPower),0,1);

    if( rmao.w==0 ){
      /////////////////////////
      // pixel was written to in the gbuffer
      float metallic = clamp(rmao.x,0.02,0.99);
      float roughness = rmao.y;
      float roughnessE = roughness*roughness;
      float roughnessL = max(.01,roughness);
      float dialetric = 1.0-metallic;
      /////////////////////////
      vec3 basecolor = gbd._albedo;
      vec3 diffcolor = mix(basecolor,vec3(0),metallic);
      /////////////////////////
      vec3 wpos = gbd._wpos;
      vec3 epos = posatdepth(wpd,0.0);
      vec3 edir = normalize(wpos-epos);
      vec3 rawn = texture(MapNormalL, uv).xyz;
      vec3 n    = normalize(rawn*2-vec3(1));
      vec3 refl = normalize(reflect(edir,n));
      /////////////////////////
      float costheta = clamp(dot(n, edir),0.01,1.0);
      vec2 brdf  = textureGather(MapBrdfIntegration, vec2(costheta,pow(roughness,0.25)),0).rg;
      ///////////////////////////
      // somethings wrong with the brdf output here
      //   we get speckled black noise
      //   the following 2 lines and the clamp above on
      //   costheta are a temporary fix
      ///////////////////////////
      //brdf = vec2(pow(brdf.x,1),pow(brdf.y,1));
      brdf = clamp(brdf,vec2(.001),vec2(1));
      /////////////////////////
      vec3 F0 = mix(metalbase,basecolor,metallic);
      vec3 F        = fresnelSchlickRoughness(costheta, F0, roughness);
      vec3 invF     = (vec3(1)-F);
      vec3 diffn = vec3(n.x,-n.y,n.z);
      /////////////////////////
      float ambocc = rmao.z;
      float ambientshade = ambocc*clamp(dot(n,-edir),0,1)*0.3+0.7;
      vec3 ambient = AmbientLevel*ambientshade;
      vec3 diffuse_env = env_equirectangular(diffn,MapDiffuseEnv,0)*DiffuseLevel;
      vec3 diffuse_light = ambient+diffuse_env;
      /////////////////////////
      vec3 diffuse = basecolor*diffuse_light*dialetric*ambocc;//*invF;
      if( rawn==vec3(0,0,0) )
        diffuse = basecolor;

      /////////////////////////
      float spec_miplevel = clamp(EnvironmentMipBias + (roughness * EnvironmentMipScale), 0, 10);
      refl = vec3(refl.x,-refl.y,refl.z);
      vec3 spec_env = env_equirectangularFlipV(refl,MapSpecularEnv,spec_miplevel);
      vec3 specular_light = ambient+spec_env;
      vec3 specular = (F*brdf.x+brdf.y)*specular_light*F0*SpecularLevel;
      //vec3 ambient = invF*AmbientLevel;
      /////////////////////////
      /////////////////////////
      // final linear color
      /////////////////////////
      vec3 finallitcolor = diffuse+specular;
      //rval = vec3(n);
      /////////////////////////
      // HDR tonemapping
      /////////////////////////
      //rval = rval / (rval + vec3(1.0));
      /////////////////////////
      // gamma correct
      /////////////////////////
      vec3 postfog = mix(finallitcolor,skyboxColor,depth_fogval);
      rval = pow(postfog, vec3(1.0/1.6));
      //rval = basecolor;
    }
    else{
      // pixel was blank to in the gbuffer
      //  replace with environment
      rval = pow(skyboxColor, vec3(1.0/1.6));
    }
    return rval;
  } // vec3 environmentLighting(){

WPosData stereoWPD(){
    WPosData wpd;
    wpd._muv   = gl_FragCoord.xy * InvViewportSize;
    int index = int(wpd._muv.x >= 0.5);
    wpd._ivp   = IVPArray[index];
    wpd._scruv = wpd._muv;
    wpd._scruv.x = mod(wpd._scruv.x * 2, 1);
    wpd._index = index;
    return wpd;
}
WPosData monoWPD(){
  WPosData wpd;
  wpd._muv   = gl_FragCoord.xy * InvViewportSize;
  wpd._index = 0;
  wpd._ivp   = IVPArray[0];
  wpd._scruv = wpd._muv;
  return wpd;
}
///////////////////////////////////////////////////////////////
} // libblock lib_deferred : ub_light : ub_frg {
///////////////////////////////////////////////////////////////
vertex_shader vs_passthru2uv : iface_v2uv {
  frg_uva     = uv0;
  frg_uvb     = uv1;
  gl_Position = position;
}
///////////////////////////////////////////////////////////////
fragment_interface iface_fdownsampledepthcluster {
  inputs {
    vec2 frg_uva;
    vec2 frg_uvb;
  }
  outputs { uint out_depthclusters; }
}
fragment_shader ps_downsampledepthcluster : iface_fdownsampledepthcluster : lib_deferred {
  vec2 base       = (gl_FragCoord.xy - vec2(0.5, 0.5)) * float(TileDim);
  uint clusterset = 0;
  for (int iy = 0; iy < TileDim; iy++) {
    for (int ix = 0; ix < TileDim; ix++) {
      vec2 uv              = base + vec2(ix, iy);
      uv                   = uv * InvViewportSize;
      float depthtex       = texture(MapDepth, uv).x;
      float ndc            = depthtex * 2.0 - 1.0;
      float zeye           = Zndc2eye.x / (ndc - Zndc2eye.y);
      uint clusterbitindex = uint(log2(zeye));
      clusterset           = clusterset | (1u << clusterbitindex);
    }
  }
  out_depthclusters = clusterset;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_baselight : iface_f2uv : lib_deferred {
  WPosData wpd = monoWPD();
  vec3 c     = baselighting(wpd);
  out_clr    = vec4(c, 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_baselight_stereo : iface_f2uv : lib_deferred {
  WPosData wpd = stereoWPD();
  vec3 c       = baselighting(wpd);
  out_clr      = vec4(c, 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_pointlight : iface_f2uv : lib_deferred {
  WPosData wpd = monoWPD();
  GBufData gbd = decodeGBUF(wpd);
  vec3 c     = pntlighting(wpd,gbd);
  /////////////////////////////////////////
  // show lighting tiles
  /////////////////////////////////////////
  //float dp5  = distance(frg_uva, vec2(.5, .5));
  //c += vec3(pow(dp5, 17) * 256.0);
  /////////////////////////////////////////
  out_clr = vec4(c, 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_pointlight_stereo : iface_f2uv : lib_deferred {
  WPosData wpd = stereoWPD();
  GBufData gbd = decodeGBUF(wpd);
  vec3 c       = pntlighting(wpd,gbd);
  out_clr = vec4(clamp(c,0,1000), 1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_environment : iface_f2uv : lib_deferred  {
  WPosData wpd = monoWPD();
  out_clr = vec4(pbrEnvironmentLighting(wpd),1);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_environment_stereo : iface_f2uv : lib_deferred  {
  WPosData wpd = stereoWPD();
  vec3 c = pbrEnvironmentLighting(wpd);
  out_clr = vec4(c,1);
}
///////////////////////////////////////////////////////////////
// StateBlocks
///////////////////////////////////////////////////////////////
state_block sb_default : default {}
///////////////////////////////////////////////////////////////
technique baselight {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_baselight;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique pointlight {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_pointlight;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique baselight_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_baselight_stereo;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique pointlight_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_pointlight_stereo;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique downsampledepthcluster {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_downsampledepthcluster;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique environmentlighting {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_environment;
    state_block     = sb_default;
  }
}
///////////////////////////////////////////////////////////////
technique environmentlighting_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader   = vs_passthru2uv;
    fragment_shader = ps_environment_stereo;
    state_block     = sb_default;
  }
}
