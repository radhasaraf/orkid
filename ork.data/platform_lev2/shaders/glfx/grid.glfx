  import "mathtools.i";
  import "misctools.i";
  import "envtools.i";
  import "picktools.i";
  import "pbrtools.i";
///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
	glsl_version = "130";
}
///////////////////////////////////////////////////////////////
uniform_set ub_fwd_grid_vtx {
  mat4 mvp;
}
vertex_interface iface_vtx_fwd_grid : ub_fwd_grid_vtx {
  inputs {
    vec4 position : POSITION;
    vec2 uv0 : TEXCOORD0;
  }
  outputs {
    vec4 frg_clr;
    vec3 frg_pos;
    vec2 frg_uv0;
  }
}
///////////////////////////////////////////////////////////////
vertex_shader vs_grid_forward
	: iface_vtx_fwd_grid {
		gl_Position = mvp*position;
		frg_uv0 = uv0;
    frg_pos = position.xyz;
}
///////////////////////////////////////////////////////////////
libblock lib_frg_grid : lib_gbuf_encode {
float filteredGrid( vec2 p, vec2 dpdx, vec2 dpdy, float width )
{
	vec2 pp = p + vec2(width,width)*0.5;

    float N = 1.0/width;
    vec2 w = max(abs(dpdx), abs(dpdy));
    vec2 a = pp + 0.5*w;                        
    vec2 b = pp - 0.5*w;           
    vec2 i = (floor(a)+min(fract(a)*N,1.0)-
              floor(b)-min(fract(b)*N,1.0))/(N*w);
    return (1.0-i.x)*(1.0-i.y);
}

vec4 grid_output(){
	vec2 paramMajor = frg_uv0+vec2(100.0,100.0);
	vec2 dpdxMajor = dFdx(paramMajor)*2;
	vec2 dpdyMajor = dFdy(paramMajor)*2;

	vec2 paramMinor = paramMajor*10.0;
	vec2 dpdxMinor = dFdx(paramMinor);
	vec2 dpdyMinor = dFdy(paramMinor);

	float gMajor = filteredGrid(paramMajor,dpdxMajor,dpdyMajor,0.02);	
	float gMinor = filteredGrid(paramMinor,dpdxMinor,dpdyMinor,0.02);	
	vec3 basecolor = vec3(0.1,0.1,0.1);
	vec3 majorcolor = vec3(1,1,1);
	vec3 minorcolor = vec3(.5,.5,.5);

	vec3 color = mix(minorcolor,basecolor,gMinor);
	vec4 oc =  vec4(mix(majorcolor,color,gMajor),1.0-gMajor);

  float xlerp = clamp(1-pow(abs(frg_pos.x*10),2),0,1);
  float zlerp = clamp(1-pow(abs(frg_pos.z*10),2),0,1);

  if(frg_pos.x<0)
    zlerp = 0.0;

  if(frg_pos.z<0)
    xlerp = 0.0;

  vec3 col_x = mix(vec3(1,1,1),vec3(0,0,1),xlerp);
  vec3 col_z = mix(vec3(1,1,1),vec3(1,0,0),zlerp);
  //oc.y *= clamp(1-pow(abs(frg_pos.y),10),0,1);
  vec3 color2 = oc.xyz*col_x*col_z;

  return vec4(color2,1);
}

}

///////////////////////////////////////////////////////////////
fragment_interface iface_fgrid_gbuffer
  : ub_frg {
  inputs {
    vec3 frg_pos;
    vec4 frg_clr;
    vec2 frg_uv0;
  }
  outputs {
    layout(location = 0) uvec4 out_gbuf;
  }
}
///////////////////////////////////////////////////////////////
fragment_interface iface_grid_forward {
  inputs {
    vec2 frg_uv0;
    vec3 frg_pos;
  }
  outputs {
    layout(location = 0) vec4 out_clr;
  }

}
fragment_shader ps_grid_forward
	: iface_grid_forward
  : lib_frg_grid {
  vec4 gout = grid_output();
  out_clr = gout; 
}
///////////////////////////////////////////////////////////////
vertex_shader vs_rigid_gbuffer_grid
  : iface_vtx_fwd_grid {
    frg_uv0 = uv0;
    frg_pos = position.xyz;
    frg_clr = vec4(1,1,1,1);
    gl_Position = mvp*position;
}
libblock lib_frgdeferred_grid_pbr : lib_frg_grid {
  void pscommon(){
    vec3 normal = vec3(0,0,0);
    float mtl = 1.0;
    float ruf = 0.0;

    vec3 grid_color = grid_output().xyz;
    out_gbuf = packGbuffer(grid_color,normal,ruf,mtl,true);

  }
}
fragment_shader ps_gbuffer_nx 
  : iface_fgrid_gbuffer
  : lib_frgdeferred_grid_pbr {
    pscommon();
}
fragment_shader ps_gbuffer_nx_stereo 
  : iface_fgrid_gbuffer
  : lib_frgdeferred_grid_pbr {
    pscommon();
}
technique GBU_CT_NM_RI_NI_MO {
	fxconfig=fxcfg_default;
	vf_pass={vs_rigid_gbuffer_grid,ps_gbuffer_nx,sb_default}
}
technique GBU_CT_NM_RI_NI_ST {
	fxconfig=fxcfg_default;
	vf_pass={vs_rigid_gbuffer_stereo,ps_gbuffer_nx_stereo,sb_default}
}
///////////////////////////////////////////////////////////////
state_block sb_additive : default {
  BlendMode = ALPHA_ADDITIVE;
  DepthTest = OFF;
  DepthMask = false;
  CullTest  = OFF;
}
technique fwd_grid {
	fxconfig=fxcfg_default;
	vf_pass={vs_grid_forward,ps_grid_forward,sb_additive}
}
