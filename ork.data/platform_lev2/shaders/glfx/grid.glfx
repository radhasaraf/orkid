import "skintools.i";
import "picktools.i";
import "pbrtools.i";
///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
	glsl_version = "130";
}
///////////////////////////////////////////////////////////////
uniform_set ub_fwd_grid_vtx {
  mat4 mvp;
}
vertex_interface iface_vtx_fwd_grid : ub_fwd_grid_vtx {
  inputs {
    vec4 position : POSITION;
    vec2 uv0 : TEXCOORD0;
  }
  outputs {
    vec4 frg_clr;
    vec2 frg_uv0;
  }
}
///////////////////////////////////////////////////////////////
vertex_shader vs_forward
	: iface_vtx_fwd_grid {
		gl_Position = mvp*position;
		frg_uv0 = uv0;
}
///////////////////////////////////////////////////////////////
libblock lib_frg_grid : lib_gbuf_encode {
float filteredGrid( vec2 p, vec2 dpdx, vec2 dpdy, float width )
{
	vec2 pp = p + vec2(width,width)*0.5;

    float N = 1.0/width;
    vec2 w = max(abs(dpdx), abs(dpdy));
    vec2 a = pp + 0.5*w;                        
    vec2 b = pp - 0.5*w;           
    vec2 i = (floor(a)+min(fract(a)*N,1.0)-
              floor(b)-min(fract(b)*N,1.0))/(N*w);
    return (1.0-i.x)*(1.0-i.y);
}

vec4 grid_output(){
	vec2 paramMajor = frg_uv0+vec2(100.0,100.0);
	vec2 dpdxMajor = dFdx(paramMajor)*2;
	vec2 dpdyMajor = dFdy(paramMajor)*2;

	vec2 paramMinor = paramMajor*10.0;
	vec2 dpdxMinor = dFdx(paramMinor);
	vec2 dpdyMinor = dFdy(paramMinor);

	float gMajor = filteredGrid(paramMajor,dpdxMajor,dpdyMajor,0.02);	
	float gMinor = filteredGrid(paramMinor,dpdxMinor,dpdyMinor,0.02);	
	vec3 basecolor = vec3(0.1,0.1,0.1);
	vec3 majorcolor = vec3(1,1,1);
	vec3 minorcolor = vec3(.5,.5,.5);

	vec3 color = mix(minorcolor,basecolor,gMinor);
	return vec4(mix(majorcolor,color,gMajor),1.0-gMajor);
}

}

libblock lib_frg_grid_pbr : lib_frg_grid {
	void pscommon(){
		vec3 normal = vec3(0,1,0);
		float mtl = 0.0;
		float ruf = 1.0;

		vec3 grid_color = grid_output().xyz;
		out_gbuf = packGbuffer(grid_color,normal,ruf,mtl,false);

	}
}
///////////////////////////////////////////////////////////////
fragment_shader ps_gbuffer_nx 
	: iface_fgbuffer
  : lib_frg_grid_pbr {
    pscommon();
}
///////////////////////////////////////////////////////////////
fragment_shader ps_gbuffer_nx_stereo 
	: iface_fgbuffer
  : lib_frg_grid_pbr {
    pscommon();
}
///////////////////////////////////////////////////////////////
fragment_interface iface_forward {
  inputs {
    vec2 frg_uv0;
  }
  outputs {
    layout(location = 0) vec4 out_clr;
  }

}
fragment_shader ps_forward
	: iface_forward
  : lib_frg_grid {
  vec4 gout = grid_output();
  out_clr = vec4(1,1,1,gout.w);
}
///////////////////////////////////////////////////////////////
technique rigid_gbuffer_n {
	fxconfig=fxcfg_default;
	vf_pass={vs_rigid_gbuffer,ps_gbuffer_nx,sb_default}
}
technique rigid_gbuffer_n_stereo {
	fxconfig=fxcfg_default;
	vf_pass={vs_rigid_gbuffer_stereo,ps_gbuffer_nx_stereo,sb_default}
}
///////////////////////////////////////////////////////////////
state_block sb_additive : default {
  BlendMode = ALPHA_ADDITIVE;
  DepthTest = OFF;
  DepthMask = false;
  CullTest  = OFF;
}
technique fwd_grid {
	fxconfig=fxcfg_default;
	vf_pass={vs_forward,ps_forward,sb_additive}
}
