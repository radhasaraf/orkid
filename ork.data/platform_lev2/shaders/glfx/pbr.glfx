///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default
{
	glsl_version = "130";
}
///////////////////////////////////////////////////////////////
// Interfaces
///////////////////////////////////////////////////////////////
uniform_set ub_vtx
{
	mat4        mv;
	mat4        mvp;
	mat3        mrot;
	vec4        modcolor;

}
///////////////////////////////////////////////////////////////
uniform_set ub_frg
{
    sampler2D ColorMap;
    sampler2D NormalMap;
    sampler2D RoughAndMetalMap;
	vec4 modcolor;
}
///////////////////////////////////////////////////////////////
// StateBlocks
///////////////////////////////////////////////////////////////
state_block sb_default : default
{
}
///////////////////////////////////////////////////////////////
// shaders
///////////////////////////////////////////////////////////////
vertex_interface iface_vgbuffer
	: ub_vtx
{
    inputs {
	    vec4 position : POSITION;
        vec3 normal : NORMAL;
        vec3 binormal : BINORMAL;
        vec4 vtxcolor : COLOR0;
	    vec2 uv0 : TEXCOORD0;
	}
    outputs {
        vec4 frg_clr;
	    vec2 frg_uv0;
	    mat3 frg_tbn;
		float frg_camdist;
		vec3 frg_camz;
	}
}
vertex_shader vs_rigid_gbuffer
	: iface_vgbuffer
{
    vec4 cpos  = mv * position;
    vec3 wnorm = normalize(mrot * normal);
    vec3 wbinorm = normalize(mrot * binormal);
	vec3 wtangent = cross(wbinorm,wnorm);
	gl_Position = mvp*position;
	frg_clr = vec4(1.0,1.0,1.0,1.0);
	frg_uv0 = uv0*vec2(1,-1);
	vec4 nrmd = vec4(wnorm,-cpos.z);
	frg_camdist = nrmd.w;
	frg_tbn = transpose(mat3(
        wtangent,
        wbinorm,
        wnorm
    ));
	frg_camz = wnorm.xyz;
}
///////////////////////////////////////////////////////////////
fragment_interface iface_fgbuffer
	: ub_frg
{
    inputs {
        vec4 frg_clr;
        vec2 frg_uv0;
	    mat3 frg_tbn;
		float frg_camdist;
		vec3 frg_camz;
	}
	outputs {
        layout(location = 0) vec4 out_clr;
        layout(location = 1) vec4 out_normal_mdl;
        layout(location = 2) vec4 out_rufmtl;
	}
}
fragment_shader ps_gbuffer
	: iface_fgbuffer
{
    vec3 ntx = frg_nrmd.xyz;
    out_clr = vec4(frg_clr.xyz,1);
    //out_normal_mdl.xyz = normalize(ntx.xyz);
	//out_normal_mdl.w = frg_nrmd.w;
}
fragment_shader ps_gbuffer_n // normalmap
	: iface_fgbuffer
{
    vec4 col = texture(ColorMap,frg_uv0).xyzw;
    vec3 nrm_tanspace = texture(NormalMap,frg_uv0).xyz*2.0-vec3(1,1,1);
    vec3 rufandmtl = vec3(texture(RoughAndMetalMap,frg_uv0).yz,1);
    nrm_tanspace = normalize(nrm_tanspace*vec3(1,1,5));

	vec3 nrm_w = normalize(nrm_tanspace*frg_tbn);


	//vec3 nxyz = vec3(frg_tbn[0].x,frg_tbn[1].x,frg_tbn[2].x);
	//nxyz = nxyz*0.5+vec3(0.5);

	//float l = dot(nrm_w,vec3(0,0,-1));
	//l = pow(l,1+rufandmtl.x*3);
	//vec3 coln = (0.5+l*0.5)*col.xyz;

    out_clr = col;
    out_normal_mdl.xyz = (nrm_w*0.5)+vec3(0.5,0.5,0.5);
	out_normal_mdl.w = frg_camdist;
	out_rufmtl = vec4(rufandmtl,1);
}
///////////////////////////////////////////////////////////////
state_block sb_pick : sb_default
{
	DepthTest=OFF;
	DepthMask=true;
	CullTest=OFF;
	BlendMode = OFF;
}
technique rigid_gbuffer
{
	fxconfig=fxcfg_default;
	pass p0
	{	vertex_shader=vs_rigid_gbuffer;
		fragment_shader=ps_gbuffer;
		state_block=sb_default;
	}
}
technique rigid_gbuffer_n
{
	fxconfig=fxcfg_default;
	pass p0
	{	vertex_shader=vs_rigid_gbuffer;
		fragment_shader=ps_gbuffer_n;
		state_block=sb_default;
	}
}
///////////////////////////////////////////////////////////////
