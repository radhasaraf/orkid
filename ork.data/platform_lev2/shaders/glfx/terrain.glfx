///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
  glsl_version = "330";
  import "misctools.i";
}
///////////////////////////////////////////////////////////////
// Interfaces
///////////////////////////////////////////////////////////////
uniform_block ublock_vtx {
  uniform mat4 MatMVP;
  uniform mat4 MatMV;
  uniform mat4 MatM;
  uniform mat4 MatV;
  uniform mat4 MatP;
  uniform mat4 MatAux;
  uniform vec4 modcolor;
  uniform float Time;
  uniform sampler2D ColorMap2; // technically a heightmap
  uniform sampler2D ColorMap3; // technically a heightmap
  uniform vec4 User0;          // aabbmin
  uniform vec4 User1;          // aabbmax
  uniform vec4 User2;          // aabbmax-aabmin
  uniform mat3 MatRotW;
}
uniform_block ublock_frg {
  uniform vec4 modcolor;
  uniform sampler2D ColorMap;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_vdefault : ublock_vtx {
  //
  in vec4 position : POSITION;
  in vec4 vtxcolor : COLOR0;
  in vec2 uv0 : TEXCOORD0;
  //
  out vec4 frg_clr;
  out vec4 frg_uv;
  out vec3 frg_nrm;
  out vec3 frg_wpos;
  out float frg_camdist;
}
fragment_interface iface_fdefault : ublock_frg {
  in vec4 frg_clr;
  in vec4 frg_uv;
  in vec3 frg_nrm;
  in vec3 frg_wpos;
  in float frg_camdist;
  //
  layout(location = 0) out vec4 out_clr;
}
///////////////////////////////////////////////////////////////
// shaders
///////////////////////////////////////////////////////////////
vertex_shader vs_terrain1
  : iface_vdefault
  : lib_terrain {
  vec3 campos = inverse(MatMV)[3].xyz;
  TerOut tero = computeTerrain(campos);
  ///////////////////////////
  // apply to GL
  ///////////////////////////
  gl_Position = MatMVP * vec4(tero.wpos, 1);
  frg_wpos = tero.wpossh;
  frg_clr = vec4(tero.wpos, 1.0);
  frg_uv = vec4(tero.uv_lowmip * 100.0, tero.wnrm.yz);
  frg_nrm = tero.wnrm;
  frg_camdist = distance(tero.wpos, campos);
}
///////////////////////////////////////////////////////////////
fragment_shader ps_terrain1
  : iface_fdefault
  : lib_mmnoise {

  float ddd1 = clamp(1.0 - frg_camdist * 0.0007, 0, 1);
  float ddd2 = clamp(1.0 - frg_camdist * 0.002, 0, 1);
  float ddd3 = clamp(1.0 - frg_camdist * 0.003, 0, 1);

  const vec3 fogcolor = vec3(0.6, 0.6, 0.7);
  const vec3 ambient = vec3(0.6, 0.6, 0.65);
  const vec3 side = vec3(0.2, 0.2, 0.25);
  const vec3 top = vec3(0.3, 0.3, 0.3);

/*  const vec3 a = vec3(0.5, 0.5, 0.5);
  const vec3 b = vec3(0.7, 0.7, 0.7);
  const vec3 c_snowcolor_near = vec3(1.3, 1.3, 1.4);
  const vec3 c_strata1_far = vec3(0.9, 0.9, 1.0);
  const vec3 c_strataandsnow_far = vec3(0.8, 0.8, 0.9);
  const vec3 c_strata1_near = vec3(1.0, 1.0, 1.1);
  const vec3 c_strataandsnow_near = vec3(0.7, 0.7, 0.8);


  float u = mod(frg_uv.x, 1);
  float v = mod(frg_uv.y, 1);


  vec3 c_snowcolor = mix(c_snowcolor_far, c_snowcolor_near, ddd2);
  vec3 c_strataandsnow = mix(c_strataandsnow_far, c_strataandsnow_near, ddd2);
  vec3 c_strata1 = mix(c_strata1_far, c_strata1_near, ddd2);

  float noiz1 = noise(frg_clr.xyz) * 0.25 * ddd3;
  float noiz2 = noise(frg_clr.xyz * 31.9) * 0.1 * ddd2;
  vec3 noiz = mix(a, b, noiz1 + noiz2);

  vec3 c_basecolor = mix(c_strata1, c_snowcolor, step(0.9, nrml.y));
  float n = 0.5 * (snoise(frg_wpos.xy * vec2(0.20, 1.5)) + 1.0);
  float strata_index = mix(0.5, n * smoothstep(0.0, 0.7, nrml.y), ddd1);

  vec3 c_strata = mix(c_strataandsnow, c_basecolor, strata_index);
  vec3 final_diffuse_color = c_strata - noiz * 0.4;

  //out_clr = vec4(final_diffuse_color * lightcol, 1);
  */
  vec3 n = normalize(frg_nrm);
  vec3 lightcol = ambient + mix(side, top, dot(n, vec3(0, 1, 0)));
  vec3 c = lightcol*mix(fogcolor,n,ddd2);
  out_clr = vec4(c,1);//+vec3(u*0.25,v*0.25,0),1);
   //out_clr = vec4(mod(frg_wpos*0.1,1),1);
}
///////////////////////////////////////////////////////////////
// pick
///////////////////////////////////////////////////////////////
vertex_interface iface_vpick : ublock_vtx {
  //
  in vec4 position : POSITION;
  //
  out vec4 frg_nrmd;
}
fragment_interface iface_fpick : ublock_frg {
  in vec4 frg_nrmd;

  layout(location = 0) out vec4 out_clr;
  layout(location = 1) out vec4 out_nrmd;
}
vertex_shader vs_pick
  : iface_vpick
  : lib_terrain {
  vec3 campos = inverse(MatMV)[3].xyz;
  TerOut tero = computeTerrain(campos);
  ///////////////////////////
  // apply to GL
  ///////////////////////////
  gl_Position = MatMVP * vec4(tero.wpos, 1);
  frg_nrmd = vec4(tero.wnrm,distance(tero.wpos, campos));
}
fragment_shader ps_pick : iface_fpick {
  out_clr = modcolor;
  out_nrmd = frg_nrmd;
}
///////////////////////////////////////////////////////////////
// StateBlocks
///////////////////////////////////////////////////////////////
state_block sb_default { inherits default; }
///////////////////////////////////////////////////////////////
technique terrain1 {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader = vs_terrain1;
    fragment_shader = ps_terrain1;
    state_block = sb_default;
  }
}
technique tek_pick {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader = vs_pick;
    fragment_shader = ps_pick;
    state_block = sb_default;
  }
}
