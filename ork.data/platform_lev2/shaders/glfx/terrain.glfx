///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
  glsl_version = "330";
  import "misctools.i";
}
///////////////////////////////////////////////////////////////
// Interfaces
///////////////////////////////////////////////////////////////
uniform_block ublock_vtx {
  uniform mat4 MatMVPL;
  uniform mat4 MatMVPC;
  uniform mat4 MatMVPR;
  uniform vec3 CamPos;
  uniform vec4 ModColor;
  uniform float Time;
  uniform sampler2D HFAMap; // technically a heightmap
  uniform sampler2D HFBMap; // technically a heightmap
}
uniform_block ublock_frg {
  uniform vec4 modcolor;
  uniform sampler2D EnvMap;
  uniform float testxxx;
  uniform vec3 FogColor;
uniform vec3 GrassColor;
uniform vec3 SnowColor;
uniform vec3 Rock1Color;
uniform vec3 Rock2Color;
uniform float GBlendYScale;
uniform float GBlendYBias;
uniform float GBlendStepLo;
uniform float GBlendStepHi;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_vdefault : ublock_vtx {
  //
  in vec4 position : POSITION;
  in vec4 vtxcolor : COLOR0;
  in vec2 uv0 : TEXCOORD0;
  //
  out vec3 frg_nrm;
  out vec2 frg_uvxp;
  out vec2 frg_uvyp;
  out vec2 frg_uvzp;
  out vec3 frg_wpos;
  out float frg_camdist;
}
fragment_interface iface_fdefault : ublock_frg {
  in vec3 frg_nrm;
  in vec2 frg_uvxp;
  in vec2 frg_uvyp;
  in vec2 frg_uvzp;
  in vec3 frg_wpos;
  in float frg_camdist;
  //
  layout(location = 0) out vec4 out_clr;
}
///////////////////////////////////////////////////////////////
// shaders
///////////////////////////////////////////////////////////////
vertex_shader vs_terrain
  : iface_vdefault
  : lib_terrain {
  TerOut tero = computeTerrain(CamPos);
  applyTerrain(tero,CamPos);
  gl_Position = MatMVPC * vec4(tero.wpos, 1);
}
///////////////////////////////////////////////////////////////
// stereo1pass
///////////////////////////////////////////////////////////////
vertex_interface iface_vstereo : iface_vdefault {
  layout(secondary_view_offset=1) out highp int gl_Layer;
}
vertex_shader vs_terrain_stereo
  : extension(GL_NV_stereo_view_rendering)
  : extension(GL_NV_viewport_array2)
  : iface_vdefault
  : lib_terrain {
  TerOut tero = computeTerrain(CamPos);
  applyTerrain(tero,CamPos);
  ///////////////////////////
  gl_Position = MatMVPL * vec4(tero.wpos, 1);
  gl_SecondaryPositionNV = MatMVPR * vec4(tero.wpos, 1);
  gl_Layer = 0;
  gl_ViewportMask[0] = 1;
  gl_SecondaryViewportMaskNV[0] = 2;
  ///////////////////////////
}
///////////////////////////////////////////////////////////////
fragment_shader ps_terrain
  : iface_fdefault
  : lib_terrain_frg {
  vec3 n = normalize(frg_nrm);
  vec3 c = albedo(n);
  const vec3 ambient = vec3(0.4);
  const vec3 side = vec3(0.2, 0.2, 0.25);
  const vec3 top = vec3(0.3, 0.3, 0.3);
  vec3 lightcol = ambient + mix(side, top, dot(n, vec3(0, 1, 0)));
  c = lightcol*mix(FogColor,c,ddd1);
  out_clr = vec4(c,1);
}
///////////////////////////////////////////////////////////////
fragment_interface iface_deferred : iface_fdefault {
  // todo (out_clr on 0 implicitly added)
  //  and adding it here conflicts
  //  so lets disable all implicit layout when
  //   any explicit layout is performed
  //layout(location = 0) out vec4 out_clr; // albedo ao
  layout(location = 1) out vec4 out_norml_mdl;
  layout(location = 2) out vec4 out_wpos_d;
}
fragment_shader ps_terrain_gbuf1
  : iface_deferred
  : lib_terrain_frg {
  vec3 n = normalize(frg_nrm);
  vec3 c = albedo(n);
  out_clr = vec4(c,1);
  vec3 yo = (n+vec3(1,1,1))*0.5;
  out_norml_mdl = vec4(n,1);
  out_wpos_d = vec4(frg_wpos,frg_camdist);
}
///////////////////////////////////////////////////////////////
// pick
///////////////////////////////////////////////////////////////
vertex_interface iface_vpick : ublock_vtx {
  //
  in vec4 position : POSITION;
  //
  out vec4 frg_nrmd;
}
fragment_interface iface_fpick : ublock_frg {
  in vec4 frg_nrmd;

  layout(location = 0) out vec4 out_clr;
  layout(location = 1) out vec4 out_nrmd;
}
vertex_shader vs_pick
  : iface_vpick
  : lib_terrain {
  TerOut tero = computeTerrain(CamPos);
  ///////////////////////////
  // apply to GL
  ///////////////////////////
  gl_Position = MatMVPC * vec4(tero.wpos, 1);
  frg_nrmd = vec4(tero.wnrm,distance(tero.wpos, CamPos));
}
fragment_shader ps_pick : iface_fpick {
  out_clr = ModColor;
  out_nrmd = frg_nrmd;
}
///////////////////////////////////////////////////////////////
// StateBlocks
///////////////////////////////////////////////////////////////
state_block sb_default { inherits default; }
///////////////////////////////////////////////////////////////
technique terrain {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader = vs_terrain;
    fragment_shader = ps_terrain;
    state_block = sb_default;
  }
}
technique terrain_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader = vs_terrain_stereo;
    fragment_shader = ps_terrain;
    state_block = sb_default;
  }
}
technique terrain_gbuf1 {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader = vs_terrain;
    fragment_shader = ps_terrain_gbuf1;
    state_block = sb_default;
  }
}
technique terrain_gbuf1_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader = vs_terrain_stereo;
    fragment_shader = ps_terrain_gbuf1;
    state_block = sb_default;
  }
}
technique tek_pick {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader = vs_pick;
    fragment_shader = ps_pick;
    state_block = sb_default;
  }
}
