///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default
{
	glsl_version = "330";
    import "misctools.i";
}
///////////////////////////////////////////////////////////////
// Interfaces
///////////////////////////////////////////////////////////////
uniform_block ublock_vtx
{
	uniform mat4        MatMVP;
    uniform mat4        MatMV;
	uniform mat4        MatM;
	uniform mat4        MatV;
	uniform mat4        MatP;
	uniform mat4        MatAux;
	uniform vec4        modcolor;
	uniform float       Time;
	uniform sampler2D ColorMap2; // technically a heightmap
	uniform vec4        User0; // aabbmin
	uniform vec4        User1; // aabbmax
	uniform vec4        User2; // aabbmax-aabmin
}
uniform_block ublock_frg
{
	uniform vec4 modcolor;
	uniform sampler2D ColorMap;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_vdefault
	: ublock_vtx
{
	//
	in vec4 position : POSITION;
	in vec4 vtxcolor : COLOR0;
	in vec2 uv0 : TEXCOORD0;
	//
	out vec4 frg_clr;
	out vec2 frg_uv;
}
fragment_interface iface_fdefault
	: ublock_frg
{
	in vec4 frg_clr;
	in vec2 frg_uv;
	//
	out vec4 out_clr;
}
///////////////////////////////////////////////////////////////
// shaders
///////////////////////////////////////////////////////////////
vertex_shader vs_terrain1
    : iface_vdefault
    : lib_terrain
{   /////////////////////////////////
    // constants
    /////////////////////////////////
    const float metersPerTexel = 2;
		const float texelsPerMeter = 1.0 / metersPerTexel;
    const float HFDIM = 2048;
    const float INVHFDIM = 1.0/HFDIM;
    const float hfHeightScale = 1500;
    const float hfHeightBias = 0;
		//float invBaseGridTexelDim = (0.1*metersPerTexel / 4.0)+(1/129.0); // inverse of num texels of base lod
		float invBaseGridTexelDim = User2.x; // inverse of num texels of base lod
    /////////////////////////////////
    // testuv
    /////////////////////////////////
    vec4 surfaceColor = vec4(0,0,.1,1);
    /////////////////////////////////
		// mipcalc
		/////////////////////////////////
    float vtxlod = position.y;
    float mippedMetersPerTexel = metersPerTexel*exp2(vtxlod);
		float invMippedMetersPerTexel = 1.0f/mippedMetersPerTexel;
    /////////////////////////////////
    // compute snapped object/worldspace
    /////////////////////////////////
    vec3 campos = inverse(MatMV)[3].xyz;
    vec2 o2w = quantize(campos.xz,mippedMetersPerTexel);
		float w_x = position.x * metersPerTexel + o2w.x;
		float w_z = position.z * metersPerTexel + o2w.y;
    vec3 wpos = vec3( w_x, 0, w_z );
    vec3 opos = (wpos - campos);
    /////////////////////////////////
    // uvgen
    /////////////////////////////////
    float size = max(0.5, max2(abs(opos.xz * 2.0 * invBaseGridTexelDim)));
    float llod = max(log2(size) - 0.75, 0.0);
    float lowMIP = floor(llod);
    float highMIP = lowMIP + 1.0;
    float htexoffsetHi = exp2(lowMIP);
    float htexoffsetLo = htexoffsetHi * 0.5;
    vec2 uvLoMip = (wpos.xz * texelsPerMeter + htexoffsetLo) * INVHFDIM;
    vec2 uvHiMip = (wpos.xz * texelsPerMeter + htexoffsetHi) * INVHFDIM;

		uvLoMip = (uvLoMip+vec2(1,1))*0.5;
		uvHiMip = (uvHiMip+vec2(1,1))*0.5;
    /////////////////////////////////
    // sample height
    /////////////////////////////////
    float heightSampleLoMip = textureLod(ColorMap2, uvLoMip, lowMIP).r;
    float heightSampleHiMip = textureLod(ColorMap2, uvHiMip, highMIP).r;
		float lerpIndex = llod - lowMIP;
    float h = mix(heightSampleLoMip,heightSampleHiMip,lerpIndex);
		/////////////////////////////////
		// final computation
		/////////////////////////////////
    wpos.y = (h*hfHeightScale)+hfHeightBias;
		//float lmipvisualize = (1.0+lowMIP)/6.0;
    ///////////////////////////
    // apply to GL
    ///////////////////////////
    gl_Position = MatMVP*vec4(wpos,1);
    //frg_clr = vec4(lmipvisualize,lmipvisualize,lmipvisualize,1);
		frg_clr = vec4(wpos,1);
    frg_uv = uvLoMip*100.0;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_terrain1
	: iface_fdefault
	: lib_mmnoise
{
	//vec3 nrml = normalize( cross(dFdx(frg_clr.xyz), dFdy(frg_clr.xyz)) );
	// derivatives are slow...
	float u = mod(frg_uv.x,1);
	float v = mod(frg_uv.y,1);
	//float nmag = 1;
	//float nmagmul = 0.5;
	float noiz1 = noise(frg_clr.xyz);
	//nmag*=nmagmul ;
	//float noiz2 = noise(frg_clr.xyz*3.9)*nmag;
	//nmag*=nmagmul ;
	//float noiz3 = noise(frg_clr.xyz*24.9)*nmag;
	//nmag*=nmagmul ;
	//float noiz4 = noise(frg_clr.xyz*64.9)*nmag;
	//float noiz = (noiz+noiz2);
	vec3 a = vec3(0.1,0.1,0.1);
	vec3 b = vec3(0.3,0.3,0.3);
	vec3 c = mix(a,b,noiz1);
	     c += vec3(u,v,0)*0.05;
	//float l = (1.0+dot(nrml,vec3(0,1,0)))*0.5;
	out_clr = vec4(c,1);
	//out_clr = frg_clr;
}
///////////////////////////////////////////////////////////////
// StateBlocks
///////////////////////////////////////////////////////////////
state_block sb_default
{
	inherits default;
}
///////////////////////////////////////////////////////////////
technique terrain1 {
	fxconfig=fxcfg_default;
	pass p0
	{	vertex_shader=vs_terrain1;
		fragment_shader=ps_terrain1;
		state_block=sb_default;
	}
}
