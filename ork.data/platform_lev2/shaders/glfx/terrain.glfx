///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default
{
	glsl_version = "330";
    import "skintools.i";
}
///////////////////////////////////////////////////////////////
// Interfaces
///////////////////////////////////////////////////////////////
uniform_block ublock_vtx
{
	uniform mat4        MatMVP;
    uniform mat4        MatMV;
	uniform mat4        MatM;
	uniform mat4        MatV;
	uniform mat4        MatP;
	uniform mat4        MatAux;
	uniform vec4        modcolor;
	uniform float       Time;
	uniform sampler2D ColorMap2; // technically a heightmap
	uniform vec4        User0; // aabbmin
	uniform vec4        User1; // aabbmax
	uniform vec4        User2; // aabbmax-aabmin
}
uniform_block ublock_frg
{
	uniform vec4 modcolor;
	uniform sampler2D ColorMap;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_vdefault
	: ublock_vtx
{
	//
	in vec4 position : POSITION;
	in vec4 vtxcolor : COLOR0;
	in vec2 uv0 : TEXCOORD0;
	//
	out vec4 frg_clr;
	out vec2 frg_uv;
}
fragment_interface iface_fdefault
	: ublock_frg
{
	in vec4 frg_clr;
	in vec2 frg_uv;
	//
	out vec4 out_clr;
}
///////////////////////////////////////////////////////////////
// shaders
///////////////////////////////////////////////////////////////
vertex_shader vs_terrain1
    : iface_vdefault
    : lib_terrain
{   /////////////////////////////////
    // constants
    /////////////////////////////////
    const float metersPerTexel = 1;
		const float texelsPerMeter = 1.0 / metersPerTexel;
    const float HFDIM = 2048;
    const float INVHFDIM = 1.0/HFDIM;
    const float hfHeightScale = 750;
    const float hfHeightBias = 0;
		//float invBaseGridTexelDim = (0.1*metersPerTexel / 4.0)+(1/129.0); // inverse of num texels of base lod
		float invBaseGridTexelDim = User2.x; // inverse of num texels of base lod
    /////////////////////////////////
    // testuv
    /////////////////////////////////
    vec4 surfaceColor = vec4(0,0,.1,1);
    /////////////////////////////////
		// mipcalc
		/////////////////////////////////
    float vtxlod = position.y;
    float mippedMetersPerTexel = metersPerTexel*exp2(vtxlod);
		float invMippedMetersPerTexel = 1.0f/mippedMetersPerTexel;
    /////////////////////////////////
    // compute snapped object/worldspace
    /////////////////////////////////
    vec3 campos = inverse(MatMV)[3].xyz;
    vec2 o2w = quantize(campos.xz,mippedMetersPerTexel);
		float w_x = position.x * metersPerTexel + o2w.x;
		float w_z = position.z * metersPerTexel + o2w.y;
    vec3 wpos = vec3( w_x, 0, w_z );
    vec3 opos = (wpos - campos);
    /////////////////////////////////
    // uvgen
    /////////////////////////////////
    float size = max(0.5, max2(abs(opos.xz * 2.0 * invBaseGridTexelDim)));
    float llod = max(log2(size) - 0.75, 0.0);
    float lowMIP = floor(llod);
    float highMIP = lowMIP + 1.0;
    float htexoffsetHi = exp2(lowMIP);
    float htexoffsetLo = htexoffsetHi * 0.5;
    vec2 uvLoMip = (wpos.xz * texelsPerMeter + htexoffsetLo) * INVHFDIM;
    vec2 uvHiMip = (wpos.xz * texelsPerMeter + htexoffsetHi) * INVHFDIM;

		uvLoMip = (uvLoMip+vec2(1,1))*0.5;
		uvHiMip = (uvHiMip+vec2(1,1))*0.5;
    /////////////////////////////////
    // sample height
    /////////////////////////////////
    float heightSampleLoMip = textureLod(ColorMap2, uvLoMip, lowMIP).r;
    float heightSampleHiMip = textureLod(ColorMap2, uvHiMip, highMIP).r;
		float lerpIndex = llod - lowMIP;
    float h = mix(heightSampleLoMip,heightSampleHiMip,lerpIndex);
		/////////////////////////////////
		// final computation
		/////////////////////////////////
    wpos.y = (h*hfHeightScale)+hfHeightBias;
		if (max(abs(uvLoMip.x - 0.5), abs(uvLoMip.y - 0.5)) > 0.5){
      //wpos.y = -100; // Fold down edges
			//surfaceColor.z = 0.3; //mod(uvLoMip.y,1);//*pow(h,0.25);
		}
		surfaceColor.x = mod(uvLoMip.x*100,1);//*pow(h,0.25);
    surfaceColor.y = mod(uvLoMip.y*100,1);//*pow(h,0.25);
		//surfaceColor.x = mod(abs(size),1);
		//surfaceColor.y = lowMIP/8.0;
    ///////////////////////////
    // apply to GL
    ///////////////////////////
    gl_Position = MatMVP*vec4(wpos,1);
    frg_clr = surfaceColor;
    frg_uv = uv0;
}
///////////////////////////////////////////////////////////////
fragment_shader ps_terrain1 : iface_fdefault
{
	out_clr = modcolor*frg_clr;
}
///////////////////////////////////////////////////////////////
// StateBlocks
///////////////////////////////////////////////////////////////
state_block sb_default
{
	inherits default;
}
///////////////////////////////////////////////////////////////
technique terrain1 {
	fxconfig=fxcfg_default;
	pass p0
	{	vertex_shader=vs_terrain1;
		fragment_shader=ps_terrain1;
		state_block=sb_default;
	}
}
