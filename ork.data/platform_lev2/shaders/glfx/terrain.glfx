///////////////////////////////////////////////////////////////
// FxConfigs
///////////////////////////////////////////////////////////////
fxconfig fxcfg_default {
  glsl_version = "330";
  import "misctools.i";
}
///////////////////////////////////////////////////////////////
// Interfaces
///////////////////////////////////////////////////////////////
uniform_block ublock_vtx {
  uniform mat4 MatMVPL;
  uniform mat4 MatMVPC;
  uniform mat4 MatMVPR;
  uniform vec3 CamPos;
  uniform vec4 ModColor;
  uniform float Time;
  uniform sampler2D HFAMap; // technically a heightmap
  uniform sampler2D HFBMap; // technically a heightmap
}
uniform_block ublock_frg {
  uniform vec4 modcolor;
  uniform sampler2D EnvMap;
}
///////////////////////////////////////////////////////////////
vertex_interface iface_vdefault : ublock_vtx {
  //
  in vec4 position : POSITION;
  in vec4 vtxcolor : COLOR0;
  in vec2 uv0 : TEXCOORD0;
  //
  out vec3 frg_nrm;
  out vec2 frg_uvxp;
  out vec2 frg_uvyp;
  out vec2 frg_uvzp;
  out vec3 frg_wpos;
  out float frg_camdist;
}
fragment_interface iface_fdefault : ublock_frg {
  in vec3 frg_nrm;
  in vec2 frg_uvxp;
  in vec2 frg_uvyp;
  in vec2 frg_uvzp;
  in vec3 frg_wpos;
  in float frg_camdist;
  //
  layout(location = 0) out vec4 out_clr;
}
///////////////////////////////////////////////////////////////
// shaders
///////////////////////////////////////////////////////////////
vertex_shader vs_terrain
  : iface_vdefault
  : lib_terrain {
  TerOut tero = computeTerrain(CamPos);
  applyTerrain(tero,CamPos);
  gl_Position = MatMVPC * vec4(tero.wpos, 1);
}
///////////////////////////////////////////////////////////////
// stereo1pass
///////////////////////////////////////////////////////////////
vertex_interface iface_vstereo : iface_vdefault {
  layout(secondary_view_offset=1) out highp int gl_Layer;
}
vertex_shader vs_terrain_stereo
  : extension(GL_NV_stereo_view_rendering)
  : extension(GL_NV_viewport_array2)
  : iface_vdefault
  : lib_terrain {
  TerOut tero = computeTerrain(CamPos);
  applyTerrain(tero,CamPos);
  ///////////////////////////
  vec4 posL = MatMVPL * vec4(tero.wpos, 1);
  vec4 posR = MatMVPR * vec4(tero.wpos, 1);
  // only x allowed to vary w/ stereo1pass
  posR.x += 0.5;
  posR.y = posL.y;
  posR.z = posL.z;
  ///////////////////////////
  gl_Position = posL;
  gl_SecondaryPositionNV = posR;
  gl_Layer = 0;
  gl_ViewportMask[0] = 1;
  gl_SecondaryViewportMaskNV[0] = 2;
  ///////////////////////////
}
///////////////////////////////////////////////////////////////
fragment_shader ps_terrain
  : iface_fdefault
  : lib_mmnoise {
  const vec3 fogcolor = vec3(0.6, 0.6, 0.7);
  const vec3 ambient = vec3(0.6, 0.6, 0.65);
  const vec3 side = vec3(0.2, 0.2, 0.25);
  const vec3 top = vec3(0.3, 0.3, 0.3);
  vec3 n = normalize(frg_nrm);
  float ddd1 = clamp(1.0 - frg_camdist * 0.0007, 0, 1);
  vec3 lightcol = ambient + mix(side, top, dot(n, vec3(0, 1, 0)));
  vec3 c = lightcol*mix(fogcolor,n,ddd1);
  out_clr = vec4(c,1);//+vec3(u*0.25,v*0.25,0),1);
}
///////////////////////////////////////////////////////////////
// pick
///////////////////////////////////////////////////////////////
vertex_interface iface_vpick : ublock_vtx {
  //
  in vec4 position : POSITION;
  //
  out vec4 frg_nrmd;
}
fragment_interface iface_fpick : ublock_frg {
  in vec4 frg_nrmd;

  layout(location = 0) out vec4 out_clr;
  layout(location = 1) out vec4 out_nrmd;
}
vertex_shader vs_pick
  : iface_vpick
  : lib_terrain {
  TerOut tero = computeTerrain(CamPos);
  ///////////////////////////
  // apply to GL
  ///////////////////////////
  gl_Position = MatMVPC * vec4(tero.wpos, 1);
  frg_nrmd = vec4(tero.wnrm,distance(tero.wpos, CamPos));
}
fragment_shader ps_pick : iface_fpick {
  out_clr = ModColor;
  out_nrmd = frg_nrmd;
}
///////////////////////////////////////////////////////////////
// StateBlocks
///////////////////////////////////////////////////////////////
state_block sb_default { inherits default; }
///////////////////////////////////////////////////////////////
technique terrain {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader = vs_terrain;
    fragment_shader = ps_terrain;
    state_block = sb_default;
  }
}
technique terrain_stereo {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader = vs_terrain_stereo;
    fragment_shader = ps_terrain;
    state_block = sb_default;
  }
}
technique tek_pick {
  fxconfig = fxcfg_default;
  pass p0 {
    vertex_shader = vs_pick;
    fragment_shader = ps_pick;
    state_block = sb_default;
  }
}
