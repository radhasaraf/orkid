datatype       <| sel{ KW_FLOAT   KW_INT 
                       KW_VEC2    KW_VEC3    KW_VEC4 
                       KW_MAT2    KW_MAT3    KW_MAT4 
                       KW_SAMP1D  KW_SAMP2D  KW_SAMP3D
                       KW_UVEC2   KW_UVEC3   KW_UVEC4 
                       KW_UMAT2   KW_UMAT3   KW_UMAT4 
                       KW_USAMP1D KW_USAMP2D KW_USAMP3D
                       KW_IVEC2   KW_IVEC3   KW_IVEC4 
                       KW_IMAT2   KW_IMAT3   KW_IMAT4 
                       KW_ISAMP1D KW_ISAMP2D KW_ISAMP3D
               }|>

TypedIdentifier <|[ sel { datatype IDENTIFIER } IDENTIFIER ]|>

constant       <| sel{INTEGER FLOATING_POINT} |>

MemberRef     <| [ DOT IDENTIFIER ] |>
ArrayRef      <| [ L_SQUARE Expression R_SQUARE ] |>

object_subref  <| sel{ MemberRef ArrayRef } |>

inh_list_item  <| [ COLON IDENTIFIER opt{ [L_PAREN IDENTIFIER R_PAREN] } ] |>
inh_list       <| zom{ inh_list_item } |>

exec_arg         <| [ Expression opt{COMMA} ] |>
exec_arglist     <| zom{ exec_arg } |>
decl_arglist     <| zom{ [ TypedIdentifier opt{COMMA} ] } |>

fn_invok <|[
    [ IDENTIFIER ] : "fni_name"
    L_PAREN ArgumentExpressionList R_PAREN
]|>

RValueConstructor <|[
    datatype
    L_PAREN
    exec_arglist
    R_PAREN
]|>

///////////////////////////////////////////////////////////

WrOnlyOperator <| EQUALS |>
RdWrOperator   <| sel{ PLUSEQ MINUSEQ STAREQ SLASHEQ } |>
UnaryOperator  <| sel{
  PLUS
  MINUS
  NOT
  TILDE
  STAR
  BITWISE_AND
}|>

///////////////////////////////////////////////////////////

datatype_wuser <| sel {
    datatype
    IDENTIFIER
}|>

UnaryExpression <| sel{
    [ PostfixExpression ]
    [ UnaryOperator CastExpression ]
}|>

CastExpression <| sel {
    [L_PAREN datatype R_PAREN CastExpression] 
    UnaryExpression
}|>

PostfixExpression <|[
    PrimaryExpression
    zom { PostfixExpressionTail }
]|>

PostfixExpressionTail <| sel{
    [ L_SQUARE Expression R_SQUARE ]
    [ L_PAREN Expression R_PAREN ]
    [ L_PAREN R_PAREN ]
    [ DOT IDENTIFIER ]
    [ PLUSPLUS ]
    [ MINUSMINUS ] 
}|>

PrimaryExpression <| sel{ 
  [ constant ]
  [ RValueConstructor ]
  [ L_PAREN Expression R_PAREN ]
  [ IDENTIFIER ] 
  // [ QUOTED_STRING ] // no strings in shadlang yet..
}|>

MultiplicativeOperation <| sel{ STAR SLASH PERCENT } |> 

MultiplicativeExpression <|[
    CastExpression
    zom{[ MultiplicativeOperation CastExpression ]}
]|>

AdditiveOperation <| sel{ PLUS MINUS } |> 

AdditiveExpression <|[
    MultiplicativeExpression
    zom{ [ AdditiveOperation MultiplicativeExpression ] }
]|>

ShiftOperation <| sel{ L_SHIFT R_SHIFT } |>

ShiftExpression <|[
    AdditiveExpression
    zom{[ ShiftOperation AdditiveExpression ]}
]|>

RelationalOperation <| sel{ L_ANGLE R_ANGLE IS_LEQ_TO IS_GEQ_TO } |>

RelationalExpression <|[
    ShiftExpression
    zom{[ ShiftOperation ShiftExpression ]}
]|>

EqualityOperation <| sel{ IS_EQ_TO IS_NEQ_TO } |>
EqualityExpression <|[
    RelationalExpression 
    zom{ [ EqualityOperation RelationalExpression ] }
]|>

AndExpression <|[
    EqualityExpression
    zom{[ BITWISE_AND EqualityExpression ]}
]|>

ExclusiveOrExpression <|[
    AndExpression
    zom{[ CARET AndExpression ]}
]|>

InclusiveOrExpression <|[
    ExclusiveOrExpression
    zom{[ BITWISE_OR ExclusiveOrExpression ]}
]|>

LogicalAndExpression <|[
    InclusiveOrExpression
    zom{[ LOGICAL_AND InclusiveOrExpression ]}
]|>

LogicalOrExpression <|[
    LogicalAndExpression
    zom{[ LOGICAL_OR LogicalAndExpression ]}
]|>

ConditionalExpression <|[
    LogicalOrExpression
]|>

AssignmentOperator <| sel{ 
    EQUALS 
    PLUSEQ 
    MINUSEQ 
    STAREQ 
    SLASHEQ 
}|>

AssignmentExpression <| sel{
    [ UnaryExpression AssignmentOperator AssignmentExpression ]
    [ ConditionalExpression ]
}|> 

ArgumentExpressionList <|[
    AssignmentExpression
    zom{ [ COMMA AssignmentExpression ] }
]|>

ConstantExpression <|[
    ConditionalExpression
]|>

Expression <|[
    AssignmentExpression
    zom{[ COMMA AssignmentExpression ]}
]|>

///////////////////////////////////////////////////////////

/*
IdentifierList <|[
    IDENTIFIER
    zom{[ COMMA IDENTIFIER ]}
]|>

ParameterDeclaration <|[
    DeclarationSpecifiers
    opt{ Declarator }
]|>

ParameterList <|[
    ParameterDeclaration
    zom{[ COMMA ParameterDeclaration ]}
]|>

ParameterTypeList <|[
    ParameterList
    opt{[ COMMA ELLIPSIS ]}
]|>

DirectDeclarator <|[
   sel{ 
       [ IDENTIFIER ]
       [ L_PAREN Declarator R_PAREN ]
   }
   zom{
    sel{
        [ L_SQUARE AssignmentExpression R_SQUARE ]
        [ L_SQUARE R_SQUARE ]
        [ L_PAREN ParameterTypeList R_PAREN ]
        [ L_PAREN IdentifierList R_PAREN ]
    }
   }
]|>

Declarator <|[ DirectDeclarator ]|>

DeclarationSpecifiers <|[
    sel{
        [ datatype ]
        [ datatype_wuser ]
    }
]|>
      
Declaration <|[
  DeclarationSpecifiers 
  opt { InitDeclaratorList }
  SEMICOLON
]|> 

InitDeclaratorList <|[
    InitDeclarator
    zom{[ COMMA InitDeclarator ]}
]|>

InitDeclarator <|[
    Declarator
    opt{[ EQUALS Initializer ]}
]|>
*/
///////////////////////////////////////////////////////////

IfStatement <|[
    KW_IF
    L_PAREN
    Expression
    R_PAREN
    statement
    opt{[
        KW_ELSE
        statement
    ]}
]|>

WhileStatement <|[
    KW_WHILE
    L_PAREN
    Expression
    R_PAREN
    statement
]|>

ForStatement <|[
    KW_FOR
    L_PAREN
    opt{ExpressionStatement}
    opt{ExpressionStatement}
    opt{Expression}
    R_PAREN
    statement
]|>

ReturnStatement <|[
    KW_RETURN
    opt{[
        Expression
    ]}
    SEMICOLON
]|>

CompoundStatementItem <| sel{
    statement
    //Declaration
}|>

CompoundStatement <|[
    L_CURLY
    zom { CompoundStatementItem }
    R_CURLY
]|>

ExpressionStatement <| sel{ 
    [ Expression SEMICOLON ]
    [ SEMICOLON ]
} |>

DiscardStatement <|[
    KW_DISCARD SEMICOLON
]|>

statement <| sel{ 
    [ DiscardStatement ]
    [ ExpressionStatement ]
    [ CompoundStatement ]
    [ IfStatement]
    [ WhileStatement]
    [ ForStatement ]
    [ ReturnStatement ]
} |>

StatementList <| zom{ statement } |>

///////////////////////////////////////////////////////////

fn_def <|[
    KW_FUNCTION
    [ IDENTIFIER ] : "fn_name"
    L_PAREN
    decl_arglist : "fn_args"
    R_PAREN
    L_CURLY
    StatementList : "fn_statements"
    R_CURLY
]|>

FunctionDef2 <|[
    sel { datatype IDENTIFIER } : "fn2_return_type"
    [ IDENTIFIER ] : "fn2_name"
    L_PAREN
    decl_arglist : "fn2_args"
    R_PAREN
    L_CURLY
    StatementList : "fn2_statements"
    R_CURLY
]|>

LibraryBlock <|[
    KW_LIBBLOCK
    [ IDENTIFIER ] : "lib_name"
    zom{inh_list_item} : "lib_dependencies"
    L_CURLY
    zom{ 
        sel{
            StructDecl
            FunctionDef2
        }
    }
    R_CURLY
]|>

VertexShader <|[
    KW_VTXSHADER
    [ IDENTIFIER ] : "vtx_name"
    zom{inh_list_item} : "vtx_dependencies"
    CompoundStatement : "vtx_statements"
]|>

GeometryShader <|[
    KW_GEOSHADER
    [ IDENTIFIER ] : "geo_name"
    zom{inh_list_item} : "geo_dependencies"
    CompoundStatement : "geo_statements"
]|>

FragmentShader <|[
    KW_FRGSHADER
    [ IDENTIFIER ] : "frg_name"
    zom{ inh_list_item } : "frg_dependencies"
    CompoundStatement : "frg_statements"
]|>

ComputeShader <|[
    KW_COMSHADER
    [ IDENTIFIER ] : "com_name"
    zom{ inh_list_item } : "com_dependencies"
    CompoundStatement : "com_statements"
]|>

data_decl <| sel {
  [TypedIdentifier] 
  [TypedIdentifier L_SQUARE INTEGER R_SQUARE] 
}|>

DataDeclarations <| zom{ [ data_decl SEMICOLON ] } |>

UniformSet <|[
  KW_UNISET
  [ IDENTIFIER ] : "uniset_name"
  L_CURLY
  DataDeclarations : "uniset_decls"
  R_CURLY
]|>

UniformBlk <|[
  KW_UNIBLK
  [ IDENTIFIER ] : "uniblk_name"
  L_CURLY
  DataDeclarations : "uniblk_decls"
  R_CURLY
]|>

InterfaceLayoutItem <| sel{
    [IDENTIFIER EQUALS INTEGER]
    [IDENTIFIER]
}|>

InterfaceLayout  <|[
   KW_LAYOUT 
   L_PAREN 
   [ 
      InterfaceLayoutItem 
      zom{ [COMMA InterfaceLayoutItem] } 
   ]
   R_PAREN
]|>

InterfaceInput <| sel{
    [ TypedIdentifier COLON IDENTIFIER ]
    [ TypedIdentifier L_SQUARE R_SQUARE ]
    [ opt{ InterfaceLayout } TypedIdentifier ]
    [ InterfaceLayout ]
}|>

InterfaceInputs <|[
  KW_INPUTS
  L_CURLY
  zom{ [ InterfaceInput SEMICOLON ] } : "inputlist"
  R_CURLY
]|>

InterfaceOutput <| sel {
    [ opt{InterfaceLayout} TypedIdentifier SEMICOLON ]
    [ InterfaceLayout SEMICOLON ]
}|>

InterfaceOutputs <|[
  KW_OUTPUTS
  L_CURLY
  zom{ 
      InterfaceOutput
  }
  R_CURLY
]|>

StructDecl <|[
    KW_STRUCT
    [ IDENTIFIER ] : "struct_name"
    L_CURLY
    [ DataDeclarations ] : "struct_decls"
    R_CURLY
    SEMICOLON
]|>

VertexInterface <|[
  KW_VTXIFACE
  [ IDENTIFIER ] : "vif_name"
  zom{ inh_list_item } : "vif_dependencies"
  L_CURLY
  opt{InterfaceInputs}
  opt{InterfaceOutputs}
  R_CURLY
]|>

GeometryInterface <|[
  KW_GEOIFACE
  [ IDENTIFIER ] : "gif_name"
  zom{ inh_list_item } : "gif_dependencies"
  L_CURLY
  opt{InterfaceInputs}
  opt{InterfaceOutputs}
  R_CURLY
]|>

FragmentInterface <|[
  KW_FRGIFACE
  [ IDENTIFIER ] : "fif_name"
  zom{ inh_list_item } : "fif_dependencies"
  L_CURLY
  opt{InterfaceInputs}
  opt{InterfaceOutputs}
  R_CURLY
]|>

sb_key <| sel{ KW_BLENDMODE KW_CULLTEST KW_DEPTHTEST KW_DEPTHMASK } |>

StateBlockItem <|[
    [ sb_key EQUALS IDENTIFIER SEMICOLON ] : "stateblock_item"
]|>

StateBlock <|[
  KW_STATEBLOCK
  [ IDENTIFIER ] : "sb_name"
  zom{ inh_list_item } : "sb_dependencies"
  L_CURLY
  zom{ StateBlockItem }
  R_CURLY
]|>

pass_binding_key <| sel{  KW_VTXSHADER KW_FRGSHADER KW_STATEBLOCK } |>

pass_binding <|[
  pass_binding_key EQUALS IDENTIFIER SEMICOLON
]|>

pass <|[
  KW_PASS
  [ IDENTIFIER ] : "pass_name"
  L_CURLY
  zom{ 
      pass_binding : "pass_item"
  }
  R_CURLY
]|>


fxconfig_ref <|[
  KW_FXCONFIG
  EQUALS
  [ IDENTIFIER ] : "fxconfigref_name"
  SEMICOLON
]|>

FxConfigKvPair <|[
  [ IDENTIFIER ] : "fxconfigkvpair_key"
  EQUALS
  [ QUOTED_STRING ] : "fxconfigkvpair_val"
  SEMICOLON
]|>

ImportDirective <|[
  KW_IMPORT
  [ QUOTED_STRING ] : "import_id"
  SEMICOLON
]|>

FxConfigDecl <|[
  KW_FXCONFIG
  [ IDENTIFIER ] : "fxconfigdecl_name"
  L_CURLY
  zom{ 
    FxConfigKvPair
  }
  zom{ 
    ImportDirective
  }
  R_CURLY
]|>

Technique <|[
  KW_TECHNIQUE
  [ IDENTIFIER ] : "technique_name"
  L_CURLY
  opt{ fxconfig_ref }
  oom{ pass }
  R_CURLY
]|>

Translatable <| 
  sel{ 
    fn_def 
    VertexShader 
    GeometryShader 
    FragmentShader 
    ComputeShader 
    UniformSet 
    UniformBlk 
    VertexInterface 
    GeometryInterface
    FragmentInterface 
    StateBlock
    Technique
    FxConfigDecl 
    LibraryBlock
  }
|>

TranslationUnit <|
  zom{ Translatable } 
|>
