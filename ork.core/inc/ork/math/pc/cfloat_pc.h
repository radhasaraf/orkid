#ifndef _CFLOAT_PC_H
#define _CFLOAT_PC_H

///////////////////////////////////////////////////////////////////////////////

#include <cstdlib>
#include <cmath>

#if defined WII
#include <revolution/os.h>
#include <revolution/base/PPCArch.h>
#endif

///////////////////////////////////////////////////////////////////////////////

namespace ork
{

///////////////////////////////////////////////////////////////////////////////
// static methods
inline float CFloat::Ceil(const float &a)
{
	return float(::std::ceil(a));
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::Floor(const float &a)
{
	return float(::std::floor(a));
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::Pow(const float &a, const float &b)
{
	return float(::std::pow(a, b));
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::Sqrt(const float &r)
{
#if defined(WII)
	//return __fsqrts(r);
	return float(::std::sqrt(r));
#else
	return float(::std::sqrt(r));
#endif
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::MAdd( float m1, float m2, float a1 )
{
#if defined(WII)
	return __fmadds(m1, m2, a1); 
#else
	return (m1*m2)+a1;
#endif
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::Cos(const float &x)
{
	return float(::std::cos(x));
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::Abs(const float &x)
{
#if defined(WII)
	return __fabsf(x); 
#else
	return maximum(x, -x);
#endif
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::ArcCos(const float &x)
{
	return float(::std::acos(x));
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::Sin(const float &x)
{
	return float(::std::sin(x));
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::ArcTan(const float &x)
{
	return float(::std::atan(x));
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::ArcTan2(const float &x, const float &y)
{
	return float(::std::atan2(x, y));
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::Tan(const float &x)
{
	return Sin(x) / Cos(x);
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::Min(const float &a, const float &b)
{
	return a < b ? a : b;
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::Max(const float &a, const float &b)
{
	return a > b ? a : b;
}

///////////////////////////////////////////////////////////////////////////////

inline float CFloat::Rand(float low, float high)
{
	static const float fdivis( 1.0f / 32768.0f );
	float fdiff = (high-low);
	float frand = float(::std::rand()&0x00007fff)*fdivis;
	return low+(frand*fdiff);
}

///////////////////////////////////////////////////////////////////////////////

inline bool CFloat::RelCompare(const float& a, const float& b, const float& toler)
{
	return CFloat::Abs(a - b) <= toler * CFloat::Max(1.0f, CFloat::Max(a, b));
}

///////////////////////////////////////////////////////////////////////////////
}
///////////////////////////////////////////////////////////////////////////////

#endif
