#ifndef _ORK_LOCALIZATION_LOCALIZEDSTRING_H_
#define _ORK_LOCALIZATION_LOCALIZEDSTRING_H_

#include <ork/kernel/string/PoolString.h>
#include <ork/Localization/Localization.h>
#include <ork/util/Context.h>
//#include <reflect/PrimitiveType.h>
//#include <reflect/string/ConstString.h>

#if 0

namespace ork { namespace reflect {
class BidirectionalSerializer;
} }

namespace ork { namespace localization {

/// used by the tool to record strings to write into .link files.
class LocalizedStringWriteContext : public util::Context<LocalizedStringWriteContext>
{
public:
	LocalizedStringWriteContext();
	int AddNextString(ConstString string);
	const orkvector<PoolString> &GetStrings();

private:
	orkvector<PoolString> mStrings;
};

/// used by the game to specify .map files to load strings from.
class LocalizedStringReadContext : public util::Context<LocalizedStringReadContext>
{
public:
	LocalizedStringReadContext(PieceString asset, bool require_prefix = false);
	TranslationMap *GetAsset() const;
	int GetNextKey();
	bool RequirePrefix() const;

private:
	bool mRequirePrefix;
	int mKey;
	TranslationMap *mAsset;
};

class LocalizedString
{
public:
	LocalizedString(TranslationKey source_key);
	LocalizedString(PieceString);
	LocalizedString();

	operator ConstString() const;
	operator PieceString() const;

	static void Serialize2(const LocalizedString *in, LocalizedString *out, ::reflect::Reflector &reflector);

	/// Serializes a string if no WriteContext is available,
	/// Otherwise write the translation key generated by the context.
	void Serialize(reflect::BidirectionalSerializer &) const;

	/// Deserializes a string if no ReadContext is available (or assert on target platforms)
	/// Otherwise read the translation key and record the asset specified by the context.
	void Deserialize(reflect::BidirectionalSerializer &);

	LocalizedString &operator=(PieceString);

	TranslationKey GetKey() const;
	TranslationMap *GetMap() const;
	
	const char *c_str() const;
	operator ::reflect::string::ConstString() const;

private:
	PoolString mString;
	TranslationKey mTranslationKey;
	TranslationMap *mTranslationMap;
};

} }

DECLARE_STATIC_REFLECTION(local, ork::localization::LocalizedString, reflect::PrimitiveType);

#endif

#endif
